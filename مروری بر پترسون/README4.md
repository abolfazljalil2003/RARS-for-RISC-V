
# عملیات سخت‌افزار کامپیوتر: دستورالعمل‌های کنترل در RISC-V

<div dir="rtl">

## مقدمه‌ای بر فیلدهای دستورالعمل RISC-V
### فیلدهای دستورالعمل:
هر دستورالعمل RISC-V شامل فیلدهایی است که برای شناسایی عملیات و آرگومان‌ها استفاده می‌شود:
- opcode (7 بیت): نوع عملیات را مشخص می‌کند.
- rs1 (5 بیت): آدرس رجیستر منبع اول.
- rs2 (5 بیت): آدرس رجیستر منبع دوم.
- rd (5 بیت): آدرس رجیستر مقصد.
- imm (12 یا 20 بیت): مقادیر فوری (Immediate).
- funct (3 یا 10 بیت): کدهای عملکردی برای افزایش اطلاعات opcode.

## دسته‌بندی دستورالعمل‌های RISC-V
RISC-V از دسته‌بندی‌های زیر برای دستورالعمل‌ها استفاده می‌کند:
1. Load و Store: انتقال داده بین حافظه و رجیستر.
2. دستورات بیت‌به‌بیت (Bitwise): عملیات منطقی و دستکاری بیت‌ها.
3. دستورات حسابی (Arithmetic): جمع، تفریق، ضرب و غیره.
4. انتقال کنترل (Control Transfer): انتقال و شاخه‌بندی (Branching).
5. دستورات شبه‌ (Pseudo): دستورالعمل‌های اختیاری برای تسهیل برنامه‌نویسی.

## فایل رجیستر در RISC-V
### ساختار:
- فایل رجیستر شامل 32 رجیستر 32 بیتی عمومی است.
- دارای دو پورت خواندن و یک پورت نوشتن است.
- این فایل سریع‌تر از حافظه اصلی است.

### عملکرد:
- تعداد بیشتر رجیسترها می‌تواند سرعت را کاهش دهد:
  - فایل 64 کلمه‌ای ممکن است 50% کندتر از فایل 32 کلمه‌ای باشد.
- افزایش تعداد پورت‌ها سرعت را به‌صورت درجه دوم تحت تأثیر قرار می‌دهد.

### مزیت اصلی:
- استفاده ساده‌تر برای کامپایلر.
- نگهداری متغیرها در رجیستر باعث بهبود تراکم کد می‌شود (چون آدرس رجیسترها کوتاه‌تر است).

## کنوانسیون نام‌گذاری رجیستر در RISC-V
جدول زیر نام‌ها و کاربرد رجیسترها را مشخص می‌کند:

| نام رجیستر | اسم ABI | توضیحات |
|------------|---------|----------|
| x0         | zero    | مقدار صفر سخت‌افزاری. |
| x1         | ra      | آدرس بازگشت (Return Address). |
| x2         | sp      | اشاره‌گر پشته (Stack Pointer). |
| x3         | gp      | اشاره‌گر عمومی (Global Pointer). |
| x4         | tp      | اشاره‌گر رشته (Thread Pointer). |
| x5-x7      | t0-t2   | رجیسترهای موقتی. |
| x8         | s0/fp   | رجیستر ذخیره / اشاره‌گر قاب. |
| x9         | s1      | رجیستر ذخیره. |
| x10-x17    | a0-a7   | آرگومان‌های تابع / مقدار بازگشتی. |
| x18-x27    | s2-s11  | رجیسترهای ذخیره. |
| x28-x31    | t3-t6   | رجیسترهای موقتی. |

## نکات تاریخی:
RISC-V یک معماری باز و انعطاف‌پذیر است که با هدف ایجاد استاندارد جدید در طراحی پردازنده‌ها توسعه یافته است. این معماری از محدودیت‌های معماری‌های قبلی عبور کرده و طراحی ساده‌تری ارائه می‌دهد.

### دستورات Case/Switch و Loop در lecture قبل توضیح داده شده (lecture 03)

## توضیحات: دستورات فراخوانی رویه‌ها در RISC-V
### فراخوانی و بازگشت از رویه‌ها
1. دستورالعمل فراخوانی رویه: jal
- `jal ra, label`: به آدرس label پرش می‌کند و مقدار PC + 4 (آدرس دستور بعدی) را در رجیستر ra ذخیره می‌کند. این مقدار ذخیره‌شده، به بازگشت کنترل به برنامه اصلی بعد از اجرای رویه کمک می‌کند.

2. بازگشت از رویه: jalr
- `jalr x0, 0(ra)`: دستور بازگشت از رویه. کنترل به آدرسی که در ra ذخیره‌شده بود، بازمی‌گردد.

### استفاده از استک در رویه‌ها
#### چرا استک؟
وقتی رویه نیاز به استفاده از تعداد زیادی رجیستر دارد که از رجیسترهای اختصاص‌یافته برای آرگومان‌ها و مقادیر بازگشتی فراتر می‌روند.

#### دستورالعمل‌های استک:
- Push: ذخیره مقدار در استک.

```assembly
sp = sp - 4  # کاهش اشاره‌گر استک
```

- Pop: بازیابی مقدار از استک.

```assembly
sp = sp + 4  # افزایش اشاره‌گر استک
```

### تعریف فریم استک (Procedure Frame):
بخشی از استک که رجیسترهای ذخیره‌شده و متغیرهای محلی را نگه می‌دارد.
- fp (اشاره‌گر فریم): به اولین کلمه از فریم اشاره دارد و یک مبنای پایدار برای رویه فراهم می‌کند.

### مثال‌ها
1. محاسبه GCD با استفاده از رویه‌ها
- کد فراخوان:

```assembly
gcd(i, j)  # i در t0 و j در t1 قرار دارند
jal ra, gcd
```

- کد رویه:

```assembly
gcd:
    # کد محاسبه GCD
    jalr x0, 0(ra)  # بازگشت به فراخواننده
```

2. کد اسمبلی برای یک رویه ساده (Leaf Procedure)
- تابع C:

```c
int leaf_ex(int g, int h, int i, int j) {
    int f = (g + h) - (i + j);
    return f;
}
```

- کد اسمبلی:

```assembly
leaf_ex:
    addi sp, sp, -8   # فضای استک ایجاد کنید
    sw t1, 4(sp)      # ذخیره t1 در استک
    sw t0, 0(sp)      # ذخیره t0 در استک
    add t0, a0, a1    # t0 = g + h
    add t1, a2, a3    # t1 = i + j
    sub s0, t0, t1    # s0 = t0 - t1
    lw t0, 0(sp)      # بازیابی t0
    lw t1, 4(sp)      # بازیابی t1
    addi sp, sp, 8    # تنظیم اشاره‌گر استک
    jalr zero, 0(ra)  # بازگشت به فراخواننده
```

### رویه‌های بازگشتی و تو در تو
1. رویه بازگشتی برای محاسبه فاکتوریل
- تابع C:

```c
int fact(int n) {
    if (n < 1) return 1;
    else return n * fact(n-1);
}
```

- کد اسمبلی:

```assembly
fact:
    addi sp, sp, -8    # فضای استک ایجاد کنید
    sw ra, 4(sp)       # ذخیره آدرس بازگشت
    sw a0, 0(sp)       # ذخیره n
    slti t0, a0, 1     # تست n < 1
    beq t0, zero, L1   # اگر n >= 1 به L1 بروید
    addi s0, zero, 1   # بازگشت مقدار 1 در s0
    addi sp, sp, 8     # تنظیم اشاره‌گر استک
    jalr zero, 0(ra)   # بازگشت
L1:
    addi a0, a0, -1    # n = n - 1
    jal ra, fact       # فراخوانی fact با (n-1)
bk_f:
    lw a0, 0(sp)       # بازیابی n
    lw ra, 4(sp)       # بازیابی آدرس بازگشت
    addi sp, sp, 8     # تنظیم اشاره‌گر استک
    mul s0, a0, s0     # s0 = n * fact(n-1)
    jalr zero, 0(ra)   # بازگشت
```

### پرسش: چه اتفاقی برای ra در رویه‌های تو در تو می‌افتد؟
- پاسخ:
هنگام فراخوانی یک رویه دیگر از داخل رویه فعلی، مقدار ra بازنویسی می‌شود. برای جلوگیری از از دست رفتن مقدار ra، باید آن را در استک ذخیره کرد و بعداً بازیابی نمود.

## خلاصه: سلسله‌مراتب ترجمه کد C به ماشین
### مراحل ترجمه کد C:
1. کد C: برنامه اولیه نوشته‌شده توسط برنامه‌نویس.
2. کامپایلر: تبدیل کد C به کد اسمبلی.
3. اسمبلر: ترجمه کد اسمبلی به کد شیء (Object Code).
4. کتابخانه‌ها: توابع و کدهای از پیش نوشته‌شده که می‌توانند به برنامه اضافه شوند.
5. لینکر: ترکیب کد شیء و کتابخانه‌ها برای تولید کد ماشین نهایی.
6. لودر: بارگذاری کد ماشین اجرایی در حافظه برای اجرا.

### مزایای بهینه‌سازی توسط کامپایلر:
#### مقایسه عملکرد در مرتب‌سازی حبابی (Bubble Sort):
- سیستم تست‌شده:
  - پردازنده Pentium 4 (3.06 GHz)، باس سیستم 533 MHz.
  - حافظه DDR SDRAM (2 گیگابایت)، سیستم‌عامل لینوکس (نسخه 2.4.20).

| نسخه GCC            | عملکرد نسبی | چرخه‌های ساعت (M) | تعداد دستورالعمل‌ها (M) | CPI  |
|---------------------|-------------|--------------------|---------------------------|------|
| بدون بهینه‌سازی    | 1.00        | 158,615            | 114,938                   | 1.38 |
| O1 (بهینه‌سازی متوسط) | 2.37        | 66,990             | 37,470                    | 1.79 |
| O2 (بهینه‌سازی کامل)  | 2.38        | 66,521             | 39,993                    | 1.66 |
| O3 (بهینه‌سازی پیشرفته) | 2.41        | 65,747             | 44,993                    | 1.46 |

### مشاهدات:
- کد بدون بهینه‌سازی دارای بهترین CPI (چرخه‌های ساعت بر دستورالعمل) است.
- نسخه O3 سریع‌ترین زمان اجرا را دارد، هرچند CPI کمی بالاتر از نسخه بدون بهینه‌سازی است.

## حالت‌های آدرس‌دهی (Addressing Modes):
به حالت‌های مختلفی که برای مشخص کردن مکان داده در حافظه یا رجیسترها استفاده می‌شود، اشاره دارد.
### مثال‌ها:
- Immediate Addressing: مقدار ثابت در دستورالعمل.
- Register Addressing: داده در رجیستر.
- Base + Offset Addressing: مکان حافظه بر اساس مقدار در یک رجیستر و یک مقدار آفست ثابت.

در فایل بعدی به توضیحاتی درباره ISA, ABI و Register File می‌پردازیم.

</div>
