
```markdown:Untitled-1.ini
# پشتیبانی از زیرروال‌ها و همگام‌سازی در معماری RISC-V

<div dir="rtl">

## فهرست مطالب
- [مقدمه](#مقدمه)
- [زیرروال‌ها در RISC-V](#زیرروال‌ها-در-risc-v)
- [مدیریت حافظه و استک](#مدیریت-حافظه-و-استک)
- [عملیات‌های همگام‌سازی](#عملیات‌های-همگام‌سازی)
- [مثال‌های کاربردی](#مثال‌های-کاربردی)

## مقدمه
زیرروال‌ها (Procedures) یا توابع (Functions) ابزارهای اساسی در برنامه‌نویسی هستند که به ساختاردهی برنامه‌ها و قابلیت استفاده مجدد از کد کمک می‌کنند. در این مستند، نحوه پیاده‌سازی و پشتیبانی از زیرروال‌ها در معماری RISC-V و همچنین مکانیزم‌های همگام‌سازی در سیستم‌های چندپردازنده‌ای را بررسی می‌کنیم.

## زیرروال‌ها در RISC-V

### دستورات اصلی
- **jal (Jump-and-Link)**:
  ```assembly
  jal x1, ProcedureAddress  # پرش به آدرس زیرروال و ذخیره آدرس بازگشت
  ```

- **jalr (Jump-and-Link Register)**:
  ```assembly
  jalr x0, 0(x1)  # بازگشت به آدرس ذخیره شده
  ```

### مثال ساده زیرروال بازگشتی
```c
int fact(int n) {
    if (n < 1) return 1;
    else return (n * fact(n - 1));
}
```

کد اسمبلی معادل:
```assembly
fact:
    addi sp, sp, -8      # تنظیم استک
    sw x1, 4(sp)         # ذخیره آدرس بازگشت
    sw x10, 0(sp)        # ذخیره پارامتر n
    # ... ادامه کد ...
```

## مدیریت حافظه و استک

### ساختار استک
- استفاده از رجیستر `sp` (x2) به عنوان اشاره‌گر استک
- ذخیره و بازیابی مقادیر با دستورات `sw` و `lw`
- مدیریت فریم استک برای متغیرهای محلی

### مثال مدیریت استک
```assembly
# ذخیره در استک
addi sp, sp, -12   # تخصیص فضا
sw x5, 8(sp)       # ذخیره رجیسترها
sw x6, 4(sp)
sw x20, 0(sp)

# بازیابی از استک
lw x20, 0(sp)      # بازیابی رجیسترها
lw x6, 4(sp)
lw x5, 8(sp)
addi sp, sp, 12    # آزادسازی فضا
```

## عملیات‌های همگام‌سازی

### مکانیزم‌های اصلی
1. **عملیات‌های اتمی**: 
   - تبادل اتمی (Atomic Exchange)
   - بارگذاری-رزرو (Load-Reserved)
   - ذخیره‌سازی-شرطی (Store-Conditional)

2. **پیاده‌سازی قفل**:
   - استفاده از مقادیر 0 (آزاد) و 1 (قفل شده)
   - جلوگیری از دسترسی همزمان با عملیات‌های اتمی

### مثال پیاده‌سازی قفل
```c
// پیاده‌سازی ساده یک قفل
void acquire_lock(int* lock) {
    while (atomic_exchange(lock, 1) == 1);
}

void release_lock(int* lock) {
    *lock = 0;
}
```

## مثال‌های کاربردی

### کپی رشته
```c
void strcpy(char x[], char y[]) {
    size_t i = 0;
    while ((x[i] = y[i]) != '\0')
        i++;
}
```

کد اسمبلی معادل:
```assembly
strcpy:
    addi sp, sp, -4     # تنظیم استک
    sw x19, 0(sp)       # ذخیره x19
    add x19, x0, x0     # i = 0
L1:
    add x5, x19, x11    # آدرس y[i]
    lbu x6, 0(x5)       # بارگذاری y[i]
    add x7, x19, x10    # آدرس x[i]
    sb x6, 0(x7)        # ذخیره x[i]
    beq x6, x0, L2      # اگر پایان رشته، خروج
    addi x19, x19, 1    # i++
    j L1                # تکرار حلقه
L2:
    lw x19, 0(sp)       # بازیابی x19
    addi sp, sp, 4      # بازگشت استک
    ret                 # بازگشت
```

</div>
```

