
# مروری بر معماری RISC-V و دستورالعمل‌های RV32I

<div dir="rtl">

## RISC-V: استاندارد باز معماری ISA

### ویژگی‌ها:
- استاندارد باز برای مجموعه دستورالعمل‌ها.
- شکاف عمده از طراحی‌های قبلی مانند MIPS.
- سازماندهی مدولار.
- ترکیبی از هسته‌های اختصاصی و متن‌باز.
- مدیریت‌شده توسط بنیاد RISC-V.

### مشخصات RISC-V:
- امکان و تشویق به افزودن توسعه‌های سفارشی.
- تأکید بر انعطاف‌پذیری.


### توسعه‌های استاندارد:

- I: دستورالعمل‌های عدد صحیح (Integer).
- M: توسعه ضرب و تقسیم عدد صحیح.
- A: توسعه اتمی.
- F: توسعه برای اعداد ممیز شناور.
- D: توسعه برای دقت مضاعف (Double Precision).
- C: توسعه فشرده‌سازی دستورالعمل‌ها.
- G: کاربرد عمومی (ترکیب IMAFD).


  توجه: تمرکز آزمایشگاه‌ها روی RV32I است.




| نام رجیستر | نام ABI | توضیحات |
|------------|---------|----------|
| x0         | zero    | مقدار ثابت صفر (سخت‌افزاری). |
| x1         | ra      | آدرس بازگشت برای زیربرنامه‌ها. |
| x2         | sp      | اشاره‌گر پشته (Stack Pointer). |
| x3         | gp      | اشاره‌گر سراسری برای داده‌های متغیرهای گلوبال. |
| x4         | tp      | اشاره‌گر رشته (Thread Pointer). |
| x5         | t0      | رجیستر موقت. |
| x6-x7      | t1-t2   | رجیسترهای موقت. |
| x8         | s0/fp   | رجیستر ذخیره‌شده / اشاره‌گر فریم. |
| x9         | s1      | رجیستر ذخیره‌شده. |
| x10-x17    | a0-a7   | آرگومان‌های تابع یا رجیستر بازگشتی. |
| x18-x27    | s2-s11  | رجیسترهای ذخیره‌شده. |
| x28-x31    | t3-t6   | رجیسترهای موقت. |

### رجیسترهای اصلی در RV32I:
#### توضیحات رجیسترهای مهم:
- ra (x1):
  - برای ذخیره آدرس بازگشت زیربرنامه استفاده می‌شود.
  - قبل از اجرای زیربرنامه، این مقدار معمولاً برابر pc + 4 تنظیم می‌شود.
- sp (x2):
  - نگهدارنده آدرس پایه پشته است.
  - آدرس پشته باید به 4 بایت تراز باشد؛ در غیر این صورت، خطای عدم تراز بارگذاری/ذخیره رخ می‌دهد.
- gp (x3):
  - نگهدارنده آدرس پایه متغیرهای گلوبال.
  - RISC-V تمام متغیرهای گلوبال را در یک ناحیه خاص قرار می‌دهد که توسط gp اشاره می‌شود.
- آرگومان‌های تابع (x10-x17):
  - این 8 رجیستر برای انتقال آرگومان‌ها به زیربرنامه‌ها استفاده می‌شوند.
  - اگر تعداد آرگومان‌ها بیشتر از 8 باشد، باقی آرگومان‌ها در پشته قرار می‌گیرند.

## فرمت‌های دستورالعمل RV32I:
### طول دستورالعمل:
- تمام دستورالعمل‌ها 32 بیتی هستند.

### فیلدها:
- opcode: (7 بیت) برای مشخص کردن عملیات.
- rs1: (5 بیت) آدرس رجیستر منبع اول.
- rs2: (5 بیت) آدرس رجیستر منبع دوم.
- rd: (5 بیت) آدرس رجیستر مقصد.
- imm: (12 یا 20 بیت) عدد فوری.
- funct: (3 یا 10 بیت) کد تکمیلی برای opcode.

### چهار نوع اصلی دستورالعمل در RV32I:
- دستورالعمل‌های Immediate:
  - مثال: addi, slti, lui.
- دستورالعمل‌های محاسبات عدد صحیح:
  - مثال: sll, sub, or, and.
- دستورالعمل‌های انتقال کنترل:
  - مثال: jal, jalr, beq.
- دستورالعمل‌های Load و Store:
  - مثال: lb, ld, sh.

### دستورالعمل‌های حسابی (Arithmetic Instructions):
#### ساختار دستورالعمل‌ها:
- هر دستورالعمل حسابی یک عملیات خاص را اجرا می‌کند.
- شامل سه عملوند است که همگی در فایل رجیستر قرار دارند.
- قالب کلی:

<div dir="ltr">
  
```plaintext
destination = source1 op source2
```

مثال:

```assembly
add t0, a1, a2  # t0 = a1 + a2
sub t0, a1, a2  # t0 = a1 - a2
```

</div>

قالب R فرمت:
- برای عملیات‌هایی که به دو رجیستر به عنوان ورودی و یک رجیستر به عنوان خروجی نیاز دارند.

### دستورالعمل‌های فوری (Immediate Instructions):
#### کاربرد:
- زمانی که از مقادیر ثابت کوچک در کد اسمبلی استفاده می‌شود.
- راه‌حل‌ها برای استفاده از مقادیر ثابت:
  - قرار دادن مقادیر در حافظه و بارگذاری آن‌ها.
  - استفاده از رجیسترهای سخت‌افزاری ثابت (مثل رجیستر صفر).
  - استفاده از دستورالعمل‌های خاص با ثابت‌های داخل آن‌ها.

مثال‌ها:

<div dir="ltr">
  
```assembly
addi sp, sp, 4   # sp = sp + 4
slti t0, s2, 15  # t0 = 1 اگر s2 < 15
```

</div>

#### فرمت I:
- مقدار ثابت در داخل دستورالعمل قرار دارد.
- مقادیر ثابت به بازه -2¹¹ تا 2¹¹-1 محدود هستند.

#### مقادیر ثابت بزرگ‌تر از 32 بیت:
- راهکار:
  - استفاده از دو دستورالعمل برای بارگذاری:
    - دستور lui برای بارگذاری 20 بیت بالا (فرمت U).
    - دستور ori برای به‌روزرسانی 12 بیت پایین (فرمت I).

مثال:

<div dir="ltr">
  
```assembly
lui t0, 0xAAAAA  # بارگذاری 20 بیت بالا
ori t0, t0, 0xAAA  # به‌روزرسانی 12 بیت پایین
```

</div>

### عملیات شیفت (Shift Operations):
#### کاربرد:
- فشرده‌سازی و باز کردن کاراکترهای 8 بیتی درون کلمات 32 بیتی.

دستورالعمل‌ها:

<div dir="ltr">
  
```assembly
slli t2, s0, 8  # t2 = s0 << 8 bits (شیفت چپ)
srli t2, s0, 8  # t2 = s0 >> 8 bits (شیفت راست)
```

</div>

#### نکته:
- شیفت‌ها به صورت منطقی انجام می‌شوند و بیت‌های خالی با صفر پر می‌شوند.
- از فیلد 5 بیتی برای مشخص کردن تعداد شیفت‌ها استفاده می‌شود.

### دستورالعمل‌های منطقی (Logical Instructions):
#### عملیات بیت‌وار:
- دستورالعمل‌های منطقی برای عملیات روی بیت‌ها:

<div dir="ltr">
  
```assembly
and t0, t1, t2  # t0 = t1 & t2
or t0, t1, t2   # t0 = t1 | t2
xor t0, t1, t2  # t0 = t1 ^ t2
```

نسخه‌های فوری:

```assembly
andi t0, t1, 0xFF00  # t0 = t1 & 0xFF00
ori t0, t1, 0xFF00   # t0 = t1 | 0xFF00
```

</div>

### مثال‌ها در شبیه‌ساز RARS:
#### مقادیر:

t0 = 0x14, t1 = 0x17, t2 = 0x03, t3 = 0x10, t4 = 37

#### نتایج:
- با استفاده از دستورات منطقی و حسابی می‌توان این مقادیر را پردازش کرد.

### دستورالعمل‌های انتقال داده در RISC-V

#### دستورالعمل‌های دسترسی به حافظه:
- دستورهای پایه برای انتقال داده‌ها:
  - دو دستور اصلی برای دسترسی به حافظه:
    - lw (بارگذاری کلمه از حافظه):

<div dir="ltr">
  
```assembly
lw t0, 4(s3)  # بارگذاری کلمه از حافظه با offset=4
```

- sw (ذخیره‌سازی کلمه در حافظه):

```assembly
sw t0, 8(s3)  # ذخیره‌سازی کلمه در حافظه با offset=8
```

</div>

#### عملکرد:
- lw: داده را از حافظه به یک رجیستر بارگذاری می‌کند.
- sw: داده را از یک رجیستر به حافظه منتقل می‌کند.

#### محاسبه آدرس حافظه:
- آدرس حافظه با جمع کردن مقدار رجیستر پایه (base register) و مقدار offset محاسبه می‌شود.
- محدودیت offset:
  - در معماری RV32I، offset یک فیلد 12 بیتی است.
  - دسترسی به حافظه در محدوده ±2 کیلوبایت از رجیستر پایه محدود می‌شود.

### تراز (Alignment) و نحوه دسترسی به بایت‌ها:
#### تراز حافظه:
- آدرس حافظه برای کلمات (4 بایت) باید مضربی از 4 باشد.
- در صورت عدم رعایت این محدودیت، خطای تراز ایجاد می‌شود.

#### اندینس (Endianness):
- روش ذخیره‌سازی بایت‌ها در حافظه:
  - Big Endian:
    - بایت چپ‌ترین (بیشترین اهمیت) به عنوان آدرس کلمه شناخته می‌شود.
    - معماری‌های MIPS، Sparc و Motorola 68k.
  - Little Endian:
    - بایت راست‌ترین (کمترین اهمیت) به عنوان آدرس کلمه شناخته می‌شود.
    - معماری‌های RISC-V و Intel x86.

### دستورالعمل‌های بارگذاری و ذخیره‌سازی بایت:
#### دستورالعمل‌های خاص برای بایت‌ها:
- lb: بارگذاری بایت از حافظه.
- sb: ذخیره‌سازی بایت در حافظه.

#### عملکرد:
- lb:
  - بایت مورد نظر را از حافظه بارگذاری کرده و در 8 بیت سمت راست رجیستر مقصد قرار می‌دهد.
  - مقدار با استفاده از بسط علامت (signed-extension) کامل می‌شود.
- sb:
  - بایت موجود در 8 بیت سمت راست یک رجیستر را به حافظه می‌نویسد.

#### مثال‌ها و تحلیل:
- کد نمونه:

<div dir="ltr">

```assembly
add s3, zero, zero   # s3 = 0
lb t0, 1(s3)         # بارگذاری بایت از آدرس 1
sb t0, 6(s3)         # ذخیره بایت در آدرس 6
```

</div>

#### پرسش‌ها:
- مقدار نهایی t0 چیست؟
- کدام کلمه در حافظه تغییر می‌کند و مقدار جدید چیست؟
- اگر معماری Big Endian باشد، چه تغییری ایجاد می‌شود؟

#### تحلیل حافظه:
- مقادیر اولیه:

<div dir="ltr">

```plaintext
Word Address (Decimal): Data
24: 0x00000000
20: 0x00000000
16: 0x00000000
12: 0x01000000
 8: 0x01000400
 4: 0xFFFFFFFF
 0: 0x0009012A
```

</div>

#### پاسخ‌ها:
- مقدار نهایی t0 برابر است با بایت بارگذاری شده از آدرس 1.
- کلمه‌ای که در آدرس حافظه تغییر می‌کند (آدرس 6) به مقدار ذخیره شده در t0 به‌روزرسانی می‌شود.
- در معماری Big Endian، موقعیت و ترتیب بایت‌ها در کلمات حافظه تغییر خواهد کرد.

### نکات تکمیلی:
- Data Transfer Instructions: دستورهایی هستند که داده‌ها را بین حافظه و ثبات‌ها منتقل می‌کنند، مانند lw (load word) برای بارگذاری داده از حافظه به ثبات و sw (store word) برای ذخیره‌سازی داده از ثبات به حافظه.
- Endianess: RISC-V از نوع "لچ‌ان‌دیان" (Little Endian) استفاده می‌کند، به این معنی که بایت‌های پایین‌تر در آدرس‌های پایین‌تر ذخیره می‌شوند.
- Alignment Restriction: در بسیاری از معماری‌ها، کلمات باید در آدرس‌هایی که مضرب 4 هستند قرار گیرند. RISC-V و Intel x86 محدودیت هم‌ترازی ندارند اما معماری MIPS محدودیت هم‌ترازی دارد.

### اهمیت بهینه‌سازی دستورات توسط کامپایلر:
- کامپایلر باید متغیرهای پرکاربرد را در ثبات‌ها نگه دارد تا هم سرعت اجرای برنامه افزایش یابد و هم مصرف انرژی کاهش پیدا کند.

### تأثیر اندازه ثبات‌ها و معماری بر عملکرد:
- تعداد محدود ثبات‌ها در RISC-V (معمولاً ۳۲ ثبات) نشان‌دهنده تعادل بین سرعت (کمتر بودن اندازه مدار) و انعطاف‌پذیری است. این موضوع یکی از اصول طراحی معماری سخت‌افزار است: "کوچک‌تر سریع‌تر است."

### معماری Little-Endian:
- RISC-V از روش آدرسی‌دهی Little-Endian استفاده می‌کند، به این معنا که بایت‌های کمتر مهم در حافظه در آدرس‌های پایین‌تر ذخیره می‌شوند. این موضوع تنها زمانی اهمیت دارد که بخواهیم داده‌ای را هم به صورت کلمه (Word) و هم به صورت بایت بخوانیم.

### استفاده از دستورهای فوری برای بهبود عملکرد:
- دستورهای فوری مانند addi که عملوند ثابت دارند، اجرای برنامه را ساده‌تر و سریع‌تر می‌کنند، زیرا نیاز به بارگذاری ثابت از حافظه را حذف می‌کنند.

### دلیل وجود حافظه پنهان (Cache):
- تفاوت سرعت زیاد بین ثبات‌ها و حافظه باعث ایجاد حافظه پنهان (Cache) شده است که به کاهش تأخیر و مصرف انرژی کمک می‌کند.

### نکات تکمیلی:
#### افزایش کند تعداد ثبات‌ها:
- معماری کامپیوتر معمولاً با برنامه‌های موجود سازگار است. از آنجا که تغییرات اساسی در ISA باعث ناسازگاری با برنامه‌های قدیمی می‌شود، تعداد ثبات‌ها به آرامی افزایش می‌یابد. این محدودیت به دلیل نیاز به حفظ سازگاری عقب‌رو است.

#### مهاجرت به 64 بیتی:
- معماری 64 بیتی امکان استفاده از فضای آدرس‌دهی بزرگ‌تر را فراهم می‌کند. این امر برای برنامه‌های مدرن که به داده‌های بزرگ‌تر و آدرس‌دهی پیشرفته‌تری نیاز دارند، ضروری است.
- با این حال، چالش‌هایی مانند ناسازگاری بین اندازه داده‌ها و سرریز وجود دارد، که نیازمند توجه دقیق در طراحی کامپایلرها است.

#### کاربرد روش آدرس‌دهی offset + base register:
- این روش در آدرس‌دهی آرایه‌ها و ساختارها بهینه است، زیرا به برنامه‌نویس اجازه می‌دهد بدون بارگذاری آدرس‌های متعدد، عناصر مختلف را با تغییر آفست دسترسی پیدا کند.
- در آرایه‌های بزرگ‌تر که آفست کافی نیست، آدرس پایه آرایه مستقیماً در ثبات نگهداری می‌شود.

#### تأثیر اندازه ثبات بر عملکرد:
- ثبات‌های بزرگ‌تر مانند RV64، امکان مدیریت داده‌های گسترده‌تر و عملیات سریع‌تر را فراهم می‌کنند. این امر به ویژه در سرورها و برنامه‌های پیشرفته مانند هوش مصنوعی و داده‌های کلان مفید است.

#### مشکلات سازگاری زبان C:
- زبان C به دلیل وابستگی به معماری سخت‌افزار، در مواجهه با تغییرات اندازه داده‌ها دچار مشکلاتی می‌شود. برنامه‌نویسان باید به تبدیل دقیق انواع داده و سرریزها توجه کنند.
- در معماری RISC-V، هر کلمه ۳۲ بیت طول دارد، که می‌تواند 2^32 ترکیب مختلف را نمایش دهد، یعنی اعداد از ۰ تا 2^32−1 (4,294,967,295 در مبنای ۱۰).

### نکات تکمیلی:
#### مزایای مکمل دو:
- جمع و تفریق اعداد مثبت و منفی با یک مدار جمع‌کننده استاندارد قابل انجام است.
- نیازی به بیت اضافی برای علامت نیست.

#### مدیریت سرریز:
- در مکمل دو، سرریز زمانی رخ می‌دهد که جمع دو عدد مثبت، عددی منفی تولید کند، یا برعکس. سخت‌افزار باید این شرایط را شناسایی کند.

#### کاربردهای معماری RISC-V:
- RISC-V از کلمات ۳۲ بیتی برای عملیات استاندارد استفاده می‌کند، که مکمل دو را برای ساده‌سازی سخت‌افزار پیاده‌سازی کرده است.

#### رابط سخت‌افزار/نرم‌افزار:
- مکمل دو نه تنها محاسبات را ساده می‌کند، بلکه تطابق سخت‌افزار و زبان‌های برنامه‌نویسی را نیز تسهیل می‌کند.

### مقایسه بارگذاری اعداد علامت‌دار و بدون علامت
- بارگذاری اعداد علامت‌دار (Signed Load) مقدار بیت علامت را در بیت‌های اضافی سمت چپ تکرار می‌کند، که به آن گسترش علامت (Sign Extension) می‌گویند. اما بارگذاری اعداد بدون علامت (Unsigned Load) بیت‌های سمت چپ را با مقدار صفر پر می‌کند.

#### مثال:
- دستور LB در RISC-V برای اعداد علامت‌دار به کار می‌رود.
- دستور LBU برای اعداد بدون علامت و معمولاً برای بارگذاری کاراکترها از حافظه استفاده می‌شود.

### گسترش علامت (Sign Extension):
- برای تبدیل عددی به اندازه بزرگ‌تر (مثلاً از 16 بیت به 32 بیت):
  - بیت علامت را در بیت‌های اضافی سمت چپ تکرار کنید.

#### مثال:
- عدد 2 به فرم 16 بیتی:

<div dir="ltr">

```plaintext
0000000000000010
```

- گسترش به 32 بیت:

```plaintext
00000000000000000000000000000010
```

- برای
