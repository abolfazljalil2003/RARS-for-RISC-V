
# مروری بر معماری RISC-V و دستورالعمل‌های RV32I

<div dir="rtl">

## RISC-V: استاندارد باز معماری ISA

### ویژگی‌ها:
- استاندارد باز برای مجموعه دستورالعمل‌ها.
- شکاف عمده از طراحی‌های قبلی مانند MIPS.
- سازماندهی مدولار.
- ترکیبی از هسته‌های اختصاصی و متن‌باز.
- مدیریت‌شده توسط بنیاد RISC-V.

### مشخصات RISC-V:
- امکان و تشویق به افزودن توسعه‌های سفارشی.
- تأکید بر انعطاف‌پذیری.


### توسعه‌های استاندارد:

- I: دستورالعمل‌های عدد صحیح (Integer).
- M: توسعه ضرب و تقسیم عدد صحیح.
- A: توسعه اتمی.
- F: توسعه برای اعداد ممیز شناور.
- D: توسعه برای دقت مضاعف (Double Precision).
- C: توسعه فشرده‌سازی دستورالعمل‌ها.
- G: کاربرد عمومی (ترکیب IMAFD).


  توجه: تمرکز آزمایشگاه‌ها روی RV32I است.




| نام رجیستر | نام ABI | توضیحات |
|------------|---------|----------|
| x0         | zero    | مقدار ثابت صفر (سخت‌افزاری). |
| x1         | ra      | آدرس بازگشت برای زیربرنامه‌ها. |
| x2         | sp      | اشاره‌گر پشته (Stack Pointer). |
| x3         | gp      | اشاره‌گر سراسری برای داده‌های متغیرهای گلوبال. |
| x4         | tp      | اشاره‌گر رشته (Thread Pointer). |
| x5         | t0      | رجیستر موقت. |
| x6-x7      | t1-t2   | رجیسترهای موقت. |
| x8         | s0/fp   | رجیستر ذخیره‌شده / اشاره‌گر فریم. |
| x9         | s1      | رجیستر ذخیره‌شده. |
| x10-x17    | a0-a7   | آرگومان‌های تابع یا رجیستر بازگشتی. |
| x18-x27    | s2-s11  | رجیسترهای ذخیره‌شده. |
| x28-x31    | t3-t6   | رجیسترهای موقت. |

### رجیسترهای اصلی در RV32I:
#### توضیحات رجیسترهای مهم:
- ra (x1):
  - برای ذخیره آدرس بازگشت زیربرنامه استفاده می‌شود.
  - قبل از اجرای زیربرنامه، این مقدار معمولاً برابر pc + 4 تنظیم می‌شود.
- sp (x2):
  - نگهدارنده آدرس پایه پشته است.
  - آدرس پشته باید به 4 بایت تراز باشد؛ در غیر این صورت، خطای عدم تراز بارگذاری/ذخیره رخ می‌دهد.
- gp (x3):
  - نگهدارنده آدرس پایه متغیرهای گلوبال.
  - RISC-V تمام متغیرهای گلوبال را در یک ناحیه خاص قرار می‌دهد که توسط gp اشاره می‌شود.
- آرگومان‌های تابع (x10-x17):
  - این 8 رجیستر برای انتقال آرگومان‌ها به زیربرنامه‌ها استفاده می‌شوند.
  - اگر تعداد آرگومان‌ها بیشتر از 8 باشد، باقی آرگومان‌ها در پشته قرار می‌گیرند.

## فرمت‌های دستورالعمل RV32I:
### طول دستورالعمل:
- تمام دستورالعمل‌ها 32 بیتی هستند.

### فیلدها:
- opcode: (7 بیت) برای مشخص کردن عملیات.
- rs1: (5 بیت) آدرس رجیستر منبع اول.
- rs2: (5 بیت) آدرس رجیستر منبع دوم.
- rd: (5 بیت) آدرس رجیستر مقصد.
- imm: (12 یا 20 بیت) عدد فوری.
- funct: (3 یا 10 بیت) کد تکمیلی برای opcode.

### چهار نوع اصلی دستورالعمل در RV32I:
- دستورالعمل‌های Immediate:
  - مثال: addi, slti, lui.
- دستورالعمل‌های محاسبات عدد صحیح:
  - مثال: sll, sub, or, and.
- دستورالعمل‌های انتقال کنترل:
  - مثال: jal, jalr, beq.
- دستورالعمل‌های Load و Store:
  - مثال: lb, ld, sh.

### دستورالعمل‌های حسابی (Arithmetic Instructions):
#### ساختار دستورالعمل‌ها:
- هر دستورالعمل حسابی یک عملیات خاص را اجرا می‌کند.
- شامل سه عملوند است که همگی در فایل رجیستر قرار دارند.
- قالب کلی:

<div dir="ltr">
  
```plaintext
destination = source1 op source2
```

مثال:

```assembly
add t0, a1, a2  # t0 = a1 + a2
sub t0, a1, a2  # t0 = a1 - a2
```

</div>

قالب R فرمت:
- برای عملیات‌هایی که به دو رجیستر به عنوان ورودی و یک رجیستر به عنوان خروجی نیاز دارند.

### دستورالعمل‌های فوری (Immediate Instructions):
#### کاربرد:
- زمانی که از مقادیر ثابت کوچک در کد اسمبلی استفاده می‌شود.
- راه‌حل‌ها برای استفاده از مقادیر ثابت:
  - قرار دادن مقادیر در حافظه و بارگذاری آن‌ها.
  - استفاده از رجیسترهای سخت‌افزاری ثابت (مثل رجیستر صفر).
  - استفاده از دستورالعمل‌های خاص با ثابت‌های داخل آن‌ها.

مثال‌ها:

<div dir="ltr">
  
```assembly
addi sp, sp, 4   # sp = sp + 4
slti t0, s2, 15  # t0 = 1 اگر s2 < 15
```

</div>

#### فرمت I:
- مقدار ثابت در داخل دستورالعمل قرار دارد.
- مقادیر ثابت به بازه -2¹¹ تا 2¹¹-1 محدود هستند.

#### مقادیر ثابت بزرگ‌تر از 32 بیت:
- راهکار:
  - استفاده از دو دستورالعمل برای بارگذاری:
    - دستور lui برای بارگذاری 20 بیت بالا (فرمت U).
    - دستور ori برای به‌روزرسانی 12 بیت پایین (فرمت I).

مثال:

<div dir="ltr">
  
```assembly
lui t0, 0xAAAAA  # بارگذاری 20 بیت بالا
ori t0, t0, 0xAAA  # به‌روزرسانی 12 بیت پایین
```

</div>

### عملیات شیفت (Shift Operations):
#### کاربرد:
- فشرده‌سازی و باز کردن کاراکترهای 8 بیتی درون کلمات 32 بیتی.

دستورالعمل‌ها:

<div dir="ltr">
  
```assembly
slli t2, s0, 8  # t2 = s0 << 8 bits (شیفت چپ)
srli t2, s0, 8  # t2 = s0 >> 8 bits (شیفت راست)
```

</div>

#### نکته:
- شیفت‌ها به صورت منطقی انجام می‌شوند و بیت‌های خالی با صفر پر می‌شوند.
- از فیلد 5 بیتی برای مشخص کردن تعداد شیفت‌ها استفاده می‌شود.

### دستورالعمل‌های منطقی (Logical Instructions):
#### عملیات بیت‌وار:
- دستورالعمل‌های منطقی برای عملیات روی بیت‌ها:

<div dir="ltr">
  
```assembly
and t0, t1, t2  # t0 = t1 & t2
or t0, t1, t2   # t0 = t1 | t2
xor t0, t1, t2  # t0 = t1 ^ t2
```

نسخه‌های فوری:

```assembly
andi t0, t1, 0xFF00  # t0 = t1 & 0xFF00
ori t0, t1, 0xFF00   # t0 = t1 | 0xFF00
```

</div>

### مثال‌ها در شبیه‌ساز RARS:
#### مقادیر:

t0 = 0x14, t1 = 0x17, t2 = 0x03, t3 = 0x10, t4 = 37

#### نتایج:
- با استفاده از دستورات منطقی و حسابی می‌توان این مقادیر را پردازش کرد.

### دستورالعمل‌های انتقال داده در RISC-V

#### دستورالعمل‌های دسترسی به حافظه:
- دستورهای پایه برای انتقال داده‌ها:
  - دو دستور اصلی برای دسترسی به حافظه:
    - lw (بارگذاری کلمه از حافظه):

<div dir="ltr">
  
```assembly
lw t0, 4(s3)  # بارگذاری کلمه از حافظه با offset=4
```

- sw (ذخیره‌سازی کلمه در حافظه):

```assembly
sw t0, 8(s3)  # ذخیره‌سازی کلمه در حافظه با offset=8
```

</div>

#### عملکرد:
- lw: داده را از حافظه به یک رجیستر بارگذاری می‌کند.
- sw: داده را از یک رجیستر به حافظه منتقل می‌کند.

#### محاسبه آدرس حافظه:
- آدرس حافظه با جمع کردن مقدار رجیستر پایه (base register) و مقدار offset محاسبه می‌شود.
- محدودیت offset:
  - در معماری RV32I، offset یک فیلد 12 بیتی است.
  - دسترسی به حافظه در محدوده ±2 کیلوبایت از رجیستر پایه محدود می‌شود.

### تراز (Alignment) و نحوه دسترسی به بایت‌ها:
#### تراز حافظه:
- آدرس حافظه برای کلمات (4 بایت) باید مضربی از 4 باشد.
- در صورت عدم رعایت این محدودیت، خطای تراز ایجاد می‌شود.

#### اندینس (Endianness):
- روش ذخیره‌سازی بایت‌ها در حافظه:
  - Big Endian:
    - بایت چپ‌ترین (بیشترین اهمیت) به عنوان آدرس کلمه شناخته می‌شود.
    - معماری‌های MIPS، Sparc و Motorola 68k.
  - Little Endian:
    - بایت راست‌ترین (کمترین اهمیت) به عنوان آدرس کلمه شناخته می‌شود.
    - معماری‌های RISC-V و Intel x86.

### دستورالعمل‌های بارگذاری و ذخیره‌سازی بایت:
#### دستورالعمل‌های خاص برای بایت‌ها:
- lb: بارگذاری بایت از حافظه.
- sb: ذخیره‌سازی بایت در حافظه.

#### عملکرد:
- lb:
  - بایت مورد نظر را از حافظه بارگذاری کرده و در 8 بیت سمت راست رجیستر مقصد قرار می‌دهد.
  - مقدار با استفاده از بسط علامت (signed-extension) کامل می‌شود.
- sb:
  - بایت موجود در 8 بیت سمت راست یک رجیستر را به حافظه می‌نویسد.

#### مثال‌ها و تحلیل:
- کد نمونه:

<div dir="ltr">

```assembly
add s3, zero, zero   # s3 = 0
lb t0, 1(s3)         # بارگذاری بایت از آدرس 1
sb t0, 6(s3)         # ذخیره بایت در آدرس 6
```

</div>

#### پرسش‌ها:
- مقدار نهایی t0 چیست؟
- کدام کلمه در حافظه تغییر می‌کند و مقدار جدید چیست؟
- اگر معماری Big Endian باشد، چه تغییری ایجاد می‌شود؟

#### تحلیل حافظه:
- مقادیر اولیه:

<div dir="ltr">

```plaintext
Word Address (Decimal): Data
24: 0x00000000
20: 0x00000000
16: 0x00000000
12: 0x01000000
 8: 0x01000400
 4: 0xFFFFFFFF
 0: 0x0009012A
```

</div>

#### پاسخ‌ها:
- مقدار نهایی t0 برابر است با بایت بارگذاری شده از آدرس 1.
- کلمه‌ای که در آدرس حافظه تغییر می‌کند (آدرس 6) به مقدار ذخیره شده در t0 به‌روزرسانی می‌شود.
- در معماری Big Endian، موقعیت و ترتیب بایت‌ها در کلمات حافظه تغییر خواهد کرد.

### نکات تکمیلی:
- Data Transfer Instructions: دستورهایی هستند که داده‌ها را بین حافظه و ثبات‌ها منتقل می‌کنند، مانند lw (load word) برای بارگذاری داده از حافظه به ثبات و sw (store word) برای ذخیره‌سازی داده از ثبات به حافظه.
- Endianess: RISC-V از نوع "لچ‌ان‌دیان" (Little Endian) استفاده می‌کند، به این معنی که بایت‌های پایین‌تر در آدرس‌های پایین‌تر ذخیره می‌شوند.
- Alignment Restriction: در بسیاری از معماری‌ها، کلمات باید در آدرس‌هایی که مضرب 4 هستند قرار گیرند. RISC-V و Intel x86 محدودیت هم‌ترازی ندارند اما معماری MIPS محدودیت هم‌ترازی دارد.

### اهمیت بهینه‌سازی دستورات توسط کامپایلر:
- کامپایلر باید متغیرهای پرکاربرد را در ثبات‌ها نگه دارد تا هم سرعت اجرای برنامه افزایش یابد و هم مصرف انرژی کاهش پیدا کند.

### تأثیر اندازه ثبات‌ها و معماری بر عملکرد:
- تعداد محدود ثبات‌ها در RISC-V (معمولاً ۳۲ ثبات) نشان‌دهنده تعادل بین سرعت (کمتر بودن اندازه مدار) و انعطاف‌پذیری است. این موضوع یکی از اصول طراحی معماری سخت‌افزار است: "کوچک‌تر سریع‌تر است."

### معماری Little-Endian:
- RISC-V از روش آدرسی‌دهی Little-Endian استفاده می‌کند، به این معنا که بایت‌های کمتر مهم در حافظه در آدرس‌های پایین‌تر ذخیره می‌شوند. این موضوع تنها زمانی اهمیت دارد که بخواهیم داده‌ای را هم به صورت کلمه (Word) و هم به صورت بایت بخوانیم.

### استفاده از دستورهای فوری برای بهبود عملکرد:
- دستورهای فوری مانند addi که عملوند ثابت دارند، اجرای برنامه را ساده‌تر و سریع‌تر می‌کنند، زیرا نیاز به بارگذاری ثابت از حافظه را حذف می‌کنند.

### دلیل وجود حافظه پنهان (Cache):
- تفاوت سرعت زیاد بین ثبات‌ها و حافظه باعث ایجاد حافظه پنهان (Cache) شده است که به کاهش تأخیر و مصرف انرژی کمک می‌کند.

### نکات تکمیلی:
#### افزایش کند تعداد ثبات‌ها:
- معماری کامپیوتر معمولاً با برنامه‌های موجود سازگار است. از آنجا که تغییرات اساسی در ISA باعث ناسازگاری با برنامه‌های قدیمی می‌شود، تعداد ثبات‌ها به آرامی افزایش می‌یابد. این محدودیت به دلیل نیاز به حفظ سازگاری عقب‌رو است.

#### مهاجرت به 64 بیتی:
- معماری 64 بیتی امکان استفاده از فضای آدرس‌دهی بزرگ‌تر را فراهم می‌کند. این امر برای برنامه‌های مدرن که به داده‌های بزرگ‌تر و آدرس‌دهی پیشرفته‌تری نیاز دارند، ضروری است.
- با این حال، چالش‌هایی مانند ناسازگاری بین اندازه داده‌ها و سرریز وجود دارد، که نیازمند توجه دقیق در طراحی کامپایلرها است.

#### کاربرد روش آدرس‌دهی offset + base register:
- این روش در آدرس‌دهی آرایه‌ها و ساختارها بهینه است، زیرا به برنامه‌نویس اجازه می‌دهد بدون بارگذاری آدرس‌های متعدد، عناصر مختلف را با تغییر آفست دسترسی پیدا کند.
- در آرایه‌های بزرگ‌تر که آفست کافی نیست، آدرس پایه آرایه مستقیماً در ثبات نگهداری می‌شود.

#### تأثیر اندازه ثبات بر عملکرد:
- ثبات‌های بزرگ‌تر مانند RV64، امکان مدیریت داده‌های گسترده‌تر و عملیات سریع‌تر را فراهم می‌کنند. این امر به ویژه در سرورها و برنامه‌های پیشرفته مانند هوش مصنوعی و داده‌های کلان مفید است.

#### مشکلات سازگاری زبان C:
- زبان C به دلیل وابستگی به معماری سخت‌افزار، در مواجهه با تغییرات اندازه داده‌ها دچار مشکلاتی می‌شود. برنامه‌نویسان باید به تبدیل دقیق انواع داده و سرریزها توجه کنند.
- در معماری RISC-V، هر کلمه ۳۲ بیت طول دارد، که می‌تواند 2^32 ترکیب مختلف را نمایش دهد، یعنی اعداد از ۰ تا 2^32−1 (4,294,967,295 در مبنای ۱۰).

### نکات تکمیلی:
#### مزایای مکمل دو:
- جمع و تفریق اعداد مثبت و منفی با یک مدار جمع‌کننده استاندارد قابل انجام است.
- نیازی به بیت اضافی برای علامت نیست.

#### مدیریت سرریز:
- در مکمل دو، سرریز زمانی رخ می‌دهد که جمع دو عدد مثبت، عددی منفی تولید کند، یا برعکس. سخت‌افزار باید این شرایط را شناسایی کند.

#### کاربردهای معماری RISC-V:
- RISC-V از کلمات ۳۲ بیتی برای عملیات استاندارد استفاده می‌کند، که مکمل دو را برای ساده‌سازی سخت‌افزار پیاده‌سازی کرده است.

#### رابط سخت‌افزار/نرم‌افزار:
- مکمل دو نه تنها محاسبات را ساده می‌کند، بلکه تطابق سخت‌افزار و زبان‌های برنامه‌نویسی را نیز تسهیل می‌کند.

### مقایسه بارگذاری اعداد علامت‌دار و بدون علامت
- بارگذاری اعداد علامت‌دار (Signed Load) مقدار بیت علامت را در بیت‌های اضافی سمت چپ تکرار می‌کند، که به آن گسترش علامت (Sign Extension) می‌گویند. اما بارگذاری اعداد بدون علامت (Unsigned Load) بیت‌های سمت چپ را با مقدار صفر پر می‌کند.

#### مثال:
- دستور LB در RISC-V برای اعداد علامت‌دار به کار می‌رود.
- دستور LBU برای اعداد بدون علامت و معمولاً برای بارگذاری کاراکترها از حافظه استفاده می‌شود.

### گسترش علامت (Sign Extension):
- برای تبدیل عددی به اندازه بزرگ‌تر (مثلاً از 16 بیت به 32 بیت):
  - بیت علامت را در بیت‌های اضافی سمت چپ تکرار کنید.

#### مثال:
- عدد 2 به فرم 16 بیتی:

<div dir="ltr">

```plaintext
0000000000000010
```

- گسترش به 32 بیت:

```plaintext
00000000000000000000000000000010
```

# RISC-V Instruction Conversion and Loops

## تبدیل عدد به اندازه بزرگ‌تر (مثلاً از 16 بیت به 32 بیت)

برای تبدیل عددی به اندازه بزرگ‌تر، بیت علامت را در بیت‌های اضافی سمت چپ تکرار کنید.
### مثال:
عدد 210 به فرم 16 بیتی:
```
0000000011010010
```
گسترش به 32 بیت:
```
00000000000000000000000011010010
```

برای عدد منفی -210:
عدد 16 بیتی:
```
1111111101011110
```
با گسترش:
```
11111111111111111111111101011110
```

## نمایش در قالب اعداد باینری

این نوع نمایش به‌عنوان قالب دستورالعمل (Instruction Format) شناخته می‌شود. به‌عنوان مثال:
```
0000000 10101 10100 000 01001 0110011
```
این قالب دقیقاً 32 بیت طول دارد (یک کلمه).

## قالب دستورالعمل RISC-V:

- **opcode:** عملیات اصلی دستورالعمل.
- **rd:** شماره رجیستری که نتیجه در آن ذخیره می‌شود.
- **funct3:** یک فیلد اضافی برای opcode.
- **rs1:** اولین عملوند رجیستر.
- **rs2:** دومین عملوند رجیستر.
- **funct7:** فیلدی اضافی برای opcode.

## نحوه ترجمه یک کد اسمبلی به زبان ماشین

### مثال:
دستورالعمل:
```
A[30] = h + A[30] + 1;
```
معادل اسمبلی:
```assembly
lw   x9, 120(x10)    // بارگذاری A[30]
add  x9, x21, x9     // جمع h با A[30]
addi x9, x9, 1       // جمع ثابت 1
sw   x9, 120(x10)    // ذخیره در A[30]
```

### مراحل تبدیل به زبان ماشین

#### دستور lw x9, 120(x10):
| فیلد | مقدار |
|------|-------|
| Immediate | 120 |
| rs1 | 10 |
| funct3 | 2 |
| rd | 9 |
| opcode | 3 |

ترکیب باینری:
```
00001111010 01010 010 01001 0000011
```

#### دستور add x9, x21, x9:
| فیلد | مقدار |
|------|-------|
| funct7 | 0 |
| rs2 | 21 |
| rs1 | 9 |
| funct3 | 0 |
| rd | 9 |
| opcode | 51 |

ترکیب باینری:
```
0000000 10101 01001 000 01001 0110011
```

#### دستور addi x9, x9, 1:
| فیلد | مقدار |
|------|-------|
| Immediate | 1 |
| rs1 | 9 |
| funct3 | 0 |
| rd | 9 |
| opcode | 19 |

ترکیب باینری:
```
00000000001 01001 000 01001 0010011
```

#### دستور sw x9, 120(x10):
| فیلد | مقدار |
|------|-------|
| Immediate[11:5] | 3 |
| rs2 | 9 |
| rs1 | 10 |
| funct3 | 2 |
| Immediate[4:0] | 24 |
| opcode | 35 |

ترکیب باینری:
```
0000011 11000 01001 01010 010 0100011
```

## دستورات شرطی در RISC-V:

- **beq rs1, rs2, L1:** اگر مقدار رجیستر rs1 برابر با rs2 بود، به دستور دارای برچسب L1 برو.
- **bne rs1, rs2, L1:** اگر مقدار رجیستر rs1 با rs2 برابر نبود، به دستور دارای برچسب L1 برو.

این دستورات به طور کلی شاخه‌های شرطی (conditional branches) نامیده می‌شوند.

### مثال:

کد C زیر را در نظر بگیرید:
```c
if (i == j) 
    f = g + h; 
else 
    f = g - h;
```

فرض کنید متغیرهای f تا j به رجیسترهای x19 تا x23 نگاشت شده باشند. کد اسمبلی RISC-V متناظر به این شکل خواهد بود:

#### بررسی شرط و شاخه‌زنی:
ابتدا بررسی می‌کنیم که آیا مقدار i و j برابر نیستند (برای افزایش بازدهی کد):
```assembly
bne x22, x23, Else       // اگر i ≠ j به Else برو
```

#### انجام عملیات "then":
اگر شرط برقرار بود، عملیات f = g + h انجام می‌شود:
```assembly
add x19, x20, x21        // f = g + h
```

#### شاخه بدون شرط:
سپس برای پرش به انتهای بلوک کد (به برچسب Exit) از یک شاخه بدون شرط استفاده می‌کنیم:
```assembly
beq x0, x0, Exit         // همیشه به Exit برو
```

#### انجام عملیات "else":
اگر شرط برقرار نبود، عملیات f = g - h انجام می‌شود و کد برچسب Else به شکل زیر است:
```assembly
Else: sub x19, x20, x21  // f = g - h
Exit:
```

## حلقه‌ها (Loops)

### مثال: کامپایل حلقه while در C

کد زیر را در نظر بگیرید:
```c
while (save[i] == k)
    i += 1;
```

فرض کنید:
- i و k به رجیسترهای x22 و x24 نگاشت شده‌اند.
- آدرس پایه آرایه save در x25 ذخیره شده است.

کد اسمبلی متناظر به این صورت نوشته می‌شود:

#### محاسبه آدرس آرایه و بارگذاری مقدار:
ابتدا باید آدرس save[i] محاسبه شود. برای این کار، شاخص i در ۴ ضرب می‌شود (زیرا آدرس‌دهی به صورت بایتی است):
```assembly
Loop: slli x10, x22, 2       // x10 = i * 4
```

سپس آدرس محاسبه‌شده را به پایه آرایه اضافه می‌کنیم:
```assembly
add x10, x10, x25            // x10 = address of save[i]
```

مقدار save[i] را در یک رجیستر موقت بارگذاری می‌کنیم:
```assembly
lw x9, 0(x10)                // x9 = save[i]
```

#### بررسی شرط حلقه:
اگر شرط برقرار نباشد (save[i] != k)، باید از حلقه خارج شویم:
```assembly
bne x9, x24, Exit             // اگر save[i] ≠ k به Exit برو
```

#### افزایش مقدار i:
در غیر این صورت، i یک واحد افزایش می‌یابد:
```assembly
addi x22, x22, 1              // i = i + 1
```

#### بازگشت به ابتدای حلقه:
در انتها باید به ابتدای حلقه برگردیم:
```assembly
beq x0, x0, Loop              // به Loop برو
Exit:
```

## دستورالعمل‌های RISC-V برای مقایسه
- **blt rs1, rs2, L1:** اگر مقدار رجیستر rs1 کمتر از rs2 باشد (اعداد علامت‌دار)، به برچسب L1 پرش می‌کند.
- **bge rs1, rs2, L1:** اگر مقدار rs1 حداقل برابر rs2 باشد (اعداد علامت‌دار)، به L1 پرش می‌کند.
- **bltu rs1, rs2, L1:** اگر مقدار rs1 کمتر از rs2 باشد (اعداد بدون علامت)، به L1 پرش می‌کند.
- **bgeu rs1, rs2, L1:** اگر مقدار rs1 حداقل برابر rs2 باشد (اعداد بدون علامت)، به L1 پرش می‌کند.

### روش‌های جایگزین برای مقایسه
#### استفاده از رجیستر موقت:
در برخی معماری‌ها (مانند MIPS)، ابتدا نتیجه مقایسه در یک رجیستر ذخیره می‌شود و سپس با استفاده از دستورات شرطی مانند beq یا bne بر اساس مقدار آن پرش انجام می‌شود.
- مزیت: سادگی در مسیر داده.
- عیب: نیاز به دستورالعمل‌های بیشتر.

#### استفاده از کدهای شرطی (Condition Codes):
معماری‌هایی مانند ARM از بیت‌های اضافی به نام کدهای شرطی یا فلگ‌ها استفاده می‌کنند که نتیجه عملیات‌های ریاضی (مانند صفر بودن، منفی بودن، یا سرریز) را ذخیره می‌کنند.
- عیب: این روش باعث ایجاد وابستگی میان دستورات می‌شود و اجرای خط لوله را پیچیده می‌کند.

## دستورات Case/Switch
بسیاری از زبان‌های برنامه‌نویسی (مانند C یا Java) دستور switch یا case دارند که انتخاب یک گزینه از میان چند گزینه را بر اساس مقدار متغیر ممکن می‌کند.
ساده‌ترین پیاده‌سازی switch استفاده از زنجیره‌ای از دستورات شرطی if-then-else است.

### روش بهینه‌تر:
استفاده از یک جدول شامل آدرس‌های دستورات مربوطه (Branch Address Table).
برنامه با استفاده از مقدار متغیر به آدرس مناسب در جدول دسترسی پیدا کرده و به آن پرش می‌کند.
در RISC-V، دستور jalr (پرش غیرمستقیم) برای این کار استفاده می‌شود:
```assembly
jalr x0, x1, 0  // پرش به آدرس ذخیره‌شده در x1
```

## مقایسه RISC-V و زبان‌های برنامه‌نویسی سطح بالا
زبان‌های برنامه‌نویسی (مانند C) دستورات زیادی برای تصمیم‌گیری و حلقه دارند، اما RISC-V دستورالعمل‌های کمی دارد.
- توضیح: دستورات بیشتر در زبان‌های سطح بالا خوانایی و درک کد را آسان‌تر می‌کنند.
- دستورالعمل‌های کمتر در RISC-V باعث سادگی سخت‌افزار و مسیر داده می‌شود.
- دستورالعمل‌های سطح بالا کدنویسی را سریع‌تر کرده و معمولاً منجر به کدهای کوتاه‌تر می‌شوند.
- کد کوتاه‌تر به معنای کاهش تعداد عملیات موردنیاز برای اجرا است.

## عملگرهای AND و OR در C و RISC-V
در C دو مجموعه عملگر برای AND (& و &&) و OR (| و ||) وجود دارد، اما در RISC-V فقط یک نوع دستور برای این عملیات‌ها وجود دارد.
توضیح:
- عملگرهای منطقی (& و |) مستقیماً در RISC-V با دستورات منطقی پیاده‌سازی می‌شوند.
- عملگرهای شرطی (&& و ||) توسط دستورات شاخه‌زنی پیاده‌سازی می‌شوند.

## جمع‌بندی نکات
- RISC-V با طراحی ساده و تعداد دستورالعمل‌های کم، سخت‌افزار و مسیر داده را بهینه می‌کند.
- زبان‌های سطح بالا، با افزودن امکانات بیشتر، کدنویسی و خوانایی را بهبود می‌بخشند.
- استفاده از ویژگی‌هایی مانند مقایسه بدون علامت می‌تواند هزینه محاسباتی را کاهش دهد و به بهینه‌سازی کد کمک کند.
```


