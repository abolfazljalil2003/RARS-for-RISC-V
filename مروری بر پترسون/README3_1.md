
# عملیات سخت‌افزار کامپیوتر

<div dir="rtl">

## عملیات حسابی در RISC-V
هر کامپیوتر باید قادر به انجام عملیات حسابی باشد. در زبان اسمبلی RISC-V، دستور زیر:

```assembly
add a, b, c
```

کامپیوتر را ملزم می‌کند که دو متغیر b و c را جمع کرده و نتیجه را در a قرار دهد. این نگارش کاملاً دقیق و ثابت است: هر دستور حسابی RISC-V فقط یک عملیات انجام می‌دهد و دقیقاً باید سه متغیر داشته باشد.

### جمع چهار متغیر
برای مثال، اگر بخواهیم مجموع چهار متغیر b، c، d و e را در متغیر a قرار دهیم، نیاز به دستورهای زیر داریم:

```assembly
add a, b, c        // مجموع b و c در a قرار می‌گیرد.
add a, a, d        // مجموع b، c و d در a ذخیره می‌شود.
add a, a, e        // مجموع b، c، d و e در a ذخیره می‌شود.
```

در نتیجه، برای جمع چهار متغیر به سه دستور نیاز داریم.

### توضیحات اضافی
- کامنت‌ها: کلمات بعد از علامت // توضیحاتی برای خواننده انسانی هستند و کامپیوتر آن‌ها را نادیده می‌گیرد.
- برخلاف زبان‌های برنامه‌نویسی دیگر، هر خط در زبان اسمبلی فقط می‌تواند یک دستور داشته باشد.
- کامنت‌ها در اسمبلی همیشه در انتهای خط پایان می‌یابند.

## اصول طراحی سخت‌افزار
تعداد طبیعی عملوندها برای عملیاتی مثل جمع، سه عملوند است:
1. دو عددی که با هم جمع می‌شوند.
2. محل ذخیره نتیجه.

لزوم استفاده از سه عملوند در هر دستور باعث ساده‌تر شدن سخت‌افزار می‌شود. اگر تعداد عملوندها متغیر باشد، طراحی سخت‌افزار پیچیده‌تر می‌شود. این موضوع اصل اول طراحی سخت‌افزار را نشان می‌دهد:
### اصل طراحی 1: سادگی، طرفدار نظم است.

## ارتباط زبان‌های سطح بالا و اسمبلی
### ترجمه دستورات ساده C به RISC-V
در زبان C، دو عبارت زیر را داریم:

```c
a = b + c;
d = a - e;
```

کامپایلر این دستورات را به زبان اسمبلی RISC-V به شکل زیر ترجمه می‌کند:

```assembly
add a, b, c
sub d, a, e
```

### ترجمه دستورات پیچیده‌تر C به RISC-V
برای عبارت پیچیده زیر:

```c
f = (g + h) - (i + j);
```

کامپایلر این عبارت را به چند دستور اسمبلی تقسیم می‌کند. چراکه هر دستور RISC-V فقط یک عملیات انجام می‌دهد. مراحل ترجمه:
ابتدا مجموع g و h را محاسبه کرده و در یک متغیر موقت (t0) قرار می‌دهیم:

```assembly
add t0, g, h    // t0 حاوی g + h
```

سپس مجموع i و j را محاسبه کرده و در متغیر موقت دیگری (t1) ذخیره می‌کنیم:

```assembly
add t1, i, j    // t1 حاوی i + j
```

در نهایت، مجموع دوم را از مجموع اول کم کرده و نتیجه را در f ذخیره می‌کنیم:

```assembly
sub f, t0, t1   // f حاوی (g + h) - (i + j)
```

### مقایسه زبان‌ها از نظر تعداد خطوط کد
برای یک تابع مشخص، کدام زبان به بیشترین تعداد خطوط کد نیاز دارد؟ ترتیب زبان‌ها:
1. RISC-V Assembly Language: به دلیل عملیات پایه و نیاز به نوشتن تمام جزئیات، بیشترین خطوط را نیاز دارد.
2. C: به دلیل سطح بالاتر نسبت به اسمبلی، خطوط کمتری نسبت به RISC-V دارد.
3. Java: معمولاً خطوط کمتری نسبت به C دارد، اما این به ساختار کلاس‌ها و سایر مفاهیم وابسته است.

### توضیحات بیشتر درباره جاوا و کامپایلر JIT
- جاوا برای افزایش قابلیت حمل‌پذیری (Portability) به یک مفسر نرم‌افزاری متکی بود.
- مجموعه دستورالعمل مفسر جاوا به نام بایت‌کد جاوا شناخته می‌شود که با مجموعه دستورالعمل‌های RISC-V تفاوت زیادی دارد.
- برای نزدیک شدن به عملکرد زبان C، سیستم‌های جاوا معمولاً بایت‌کدها را به مجموعه دستورالعمل‌های بومی مانند RISC-V کامپایل می‌کنند.
- کامپایلرهای جاوا، به دلیل انجام این عملیات در لحظه اجرا (Just-In-Time)، به کامپایلرهای JIT معروف هستند.

یادگیری زبان اسمبلی RISC-V کمک می‌کند تا اصول اساسی طراحی سخت‌افزار و ارتباط آن با نرم‌افزار را بهتر درک کنید.

## Operands of the Computer Hardware (عملگرهای سخت‌افزاری کامپیوتر)
برخلاف برنامه‌ها در زبان‌های سطح بالا، عملگرهای دستورات حسابی محدود هستند؛ آن‌ها باید از تعداد محدودی مکان خاص که به طور مستقیم در سخت‌افزار ساخته شده‌اند، به نام ثبات‌ها (Registers) انتخاب شوند. ثبات‌ها اجزای اصلی در طراحی سخت‌افزار هستند که پس از تکمیل شدن کامپیوتر، برای برنامه‌نویس قابل مشاهده خواهند بود. بنابراین می‌توان به ثبات‌ها به چشم آجرهای ساخت کامپیوتر نگاه کرد. اندازه یک ثبات در معماری RISC-V برابر با 32 بیت است؛ گروه‌های 32 بیتی به قدری رایج هستند که در معماری RISC-V به آن‌ها "کلمه" (word) گفته می‌شود. (یک اندازه دیگر که بسیار رایج است، گروهی از 64 بیت است که به آن "دبل‌ورد" (doubleword) گفته می‌شود.)

### اصل طراحی 2: کوچکتر سریع‌تر است.
اگر تعداد ثبات‌ها زیاد باشد، ممکن است زمان چرخه ساعت افزایش یابد، زیرا سیگنال‌های الکترونیکی برای حرکت در فواصل بیشتر زمان بیشتری می‌برند. اصولی مانند "کوچکتر سریع‌تر است" قطعی نیستند؛ 31 ثبات ممکن است از 32 سریع‌تر نباشد، اما حقیقت پشت چنین مشاهداتی باعث می‌شود که طراحان کامپیوتر این اصول را جدی بگیرند.

یکی دیگر از دلایل عدم استفاده از بیش از 32 ثبات، تعداد بیتی است که در فرمت دستورالعمل‌ها باید استفاده شود.

### استفاده از ثبات‌ها در ساختمان سخت‌افزار
در فصل 4، نقش مرکزی ثبات‌ها در ساخت سخت‌افزار نشان داده می‌شود؛ همانطور که در آن فصل خواهیم دید، استفاده مؤثر از ثبات‌ها برای عملکرد برنامه حیاتی است.

### ترجمه و مثال در کدنویسی C با استفاده از ثبات‌ها:
کار کامپایلر این است که متغیرهای برنامه را با ثبات‌ها مرتبط کند. به عنوان مثال، عبارت انتسابی زیر را در نظر بگیرید:

```c
f = (g + h) − (i + j);
```

در این مثال، متغیرهای f، g، h، i و j به ترتیب به ثبات‌های x19، x20، x21، x22 و x23 اختصاص داده شده‌اند. کد RISC-V تولید شده به شکل زیر خواهد بود:

```assembly
add x5, x20, x21  // x5 = g + h
add x6, x22, x23  // x6 = i + j
sub x19, x5, x6   // f = x5 - x6
```

## Operands in Memory (عملگرهای در حافظه)
زبان‌های برنامه‌نویسی متغیرهای ساده‌ای دارند که شامل داده‌های منفرد هستند، اما آن‌ها همچنین ساختارهای پیچیده‌تری مانند آرایه‌ها و ساختارها نیز دارند. این ساختارهای ترکیبی می‌توانند داده‌های بیشتری نسبت به تعداد ثبات‌ها در کامپیوتر را در خود جای دهند. کامپیوتر چطور می‌تواند چنین ساختارهای بزرگی را نمایش دهد و به آن‌ها دسترسی پیدا کند؟

همانطور که در بخش قبلی اشاره شد، عملیات حسابی تنها روی ثبات‌ها در دستورات RISC-V صورت می‌گیرد. بنابراین، معماری RISC-V باید دستوراتی برای انتقال داده‌ها بین حافظه و ثبات‌ها داشته باشد که به آن‌ها دستورهای انتقال داده (Data Transfer Instructions) گفته می‌شود.

### مثال در زبان C برای دسترسی به داده‌های در حافظه:
فرض کنید که A یک آرایه از 100 کلمه است و آدرس پایه آرایه در ثبات x22 ذخیره شده است. اکنون عبارت انتسابی زیر را در نظر بگیرید:

```c
g = h + A[8];
```

برای این‌که A[8] را از حافظه بارگذاری کنیم، باید آدرس آن را با استفاده از آدرس پایه آرایه و اندیس 8 به دست آوریم:

```assembly
lw x9, 8(x22)  // بارگذاری A[8] به x9
add x20, x21, x9  // g = h + A[8]
```

### نکات تکمیلی:
- Data Transfer Instructions: دستورهایی هستند که داده‌ها را بین حافظه و ثبات‌ها منتقل می‌کنند، مانند lw (load word) برای بارگذاری داده از حافظه به ثبات و sw (store word) برای ذخیره‌سازی داده از ثبات به حافظه.
- Endianess: RISC-V از نوع "لچ‌ان‌دیان" (Little Endian) استفاده می‌کند، به این معنی که بایت‌های پایین‌تر در آدرس‌های پایین‌تر ذخیره می‌شوند.
- Alignment Restriction: در بسیاری از معماری‌ها، کلمات باید در آدرس‌هایی که مضرب 4 هستند قرار گیرند. RISC-V و Intel x86 محدودیت هم‌ترازی ندارند اما معماری MIPS محدودیت هم‌ترازی دارد.



</div>
