```markdown name=README.md
# کامپیوتر چیست؟

<div dir="rtl">

یک کامپیوتر شامل اجزای اصلی زیر است:

### پردازنده (Processor):

شامل دو بخش:
- مسیر داده (Datapath): مسئول انتقال و پردازش داده.
- واحد کنترل (Control): مسئول مدیریت اجرای دستورات.

### ورودی (Input):

دستگاه‌هایی مانند ماوس و صفحه‌کلید که داده‌ها را به کامپیوتر وارد می‌کنند.

### خروجی (Output):

دستگاه‌هایی مانند صفحه‌نمایش و چاپگر که نتایج پردازش را به کاربر نشان می‌دهند.

### حافظه (Memory):

شامل سطوح مختلف:
- حافظه کش (Cache): نزدیک‌ترین حافظه به پردازنده برای دسترسی سریع.
- حافظه اصلی (Main Memory): ذخیره داده‌های فعال برنامه.
- حافظه‌های ذخیره‌سازی (مانند دیسک سخت یا CD/DVD): ذخیره طولانی‌مدت داده‌ها.

### شبکه (Network):

برای اتصال کامپیوتر به دستگاه‌ها و سیستم‌های دیگر.

تمرکز اصلی در این درس: پردازنده (مسیر داده و کنترل) و تعامل آن با سیستم‌های حافظه. پردازنده‌ها با استفاده از ده‌ها یا صدها میلیون ترانزیستور ساخته می‌شوند، اما بررسی تک‌تک این ترانزیستورها غیرممکن است. راه‌حل: استفاده از انتزاع (Abstraction) برای مدیریت پیچیدگی.

## اجزای اصلی یک کامپیوتر:

کامپیوتر شامل سه لایه اصلی است:

### برنامه‌های کاربردی (Applications):

شامل ویرایشگرهای متن، پخش‌کننده‌های موسیقی و ویدیو، مرورگرهای وب، بازی‌ها و ابزارهای دیگر.

### سیستم‌عامل (Operating System):

مسئول مدیریت سخت‌افزار و ارائه خدمات به برنامه‌ها.

بخش‌های اصلی:
- هسته (Kernel): اجرای اصلی سیستم‌عامل.
- فایل سیستم (File Systems): مدیریت فایل‌ها.
- درایورهای دستگاه (Device Drivers): ارتباط با سخت‌افزار.
- امنیت و رابط‌های کاربری (GUI، API).

### سخت‌افزار (Hardware):

شامل پردازنده، حافظه، دستگاه‌های ذخیره‌سازی، نمایشگر، آداپتور شبکه، و دستگاه‌های ورودی/خروجی.

## سازمان ماشین (Machine Organization):

### واحدهای عملکردی اصلی (Functional Units - FUs):

مانند فایل رجیسترها، واحد حساب و منطق (ALU)، مولتی‌پلکسرها، و حافظه‌ها. هر یک از این واحدها قابلیت‌ها و ویژگی‌های عملکردی خاص خود را دارند.

### اتصالات بین واحدها:

واحدهای عملکردی از طریق باس‌ها (Buses) به یکدیگر متصل می‌شوند.

### کنترل جریان اطلاعات:

منطق و روش‌هایی که جریان داده بین واحدهای عملکردی را کنترل می‌کنند.

### معماری مجموعه دستورات (Instruction Set Architecture - ISA):

مشخص می‌کند که پردازنده چه دستورات و عملیات‌هایی را پشتیبانی می‌کند.

### توضیحات در سطح انتقال رجیستر (Register Transfer Level - RTL):

توصیف رفتار کامپیوتر در سطح عملیات رجیسترها و انتقال داده‌ها بین آن‌ها.

## توضیح کلی:

مطالعه معماری کامپیوتر شامل درک اجزای مختلف سخت‌افزار و نحوه تعامل آن‌هاست. هدف این است که نه تنها نحوه عملکرد پردازنده را بفهمیم، بلکه تأثیر طراحی آن را بر برنامه‌ها و عملکرد کلی سیستم بررسی کنیم. انتزاع ابزاری حیاتی برای ساده‌سازی پیچیدگی سیستم‌های کامپیوتری است.

## سازمان پردازنده (Processor Organization):

### کنترل (Control):

کنترل وظیفه مدیریت و هدایت عملیات پردازنده را بر عهده دارد. برای این کار، مدارهای زیر لازم است:
- انتخاب دستور بعدی: تعیین و دریافت دستورالعمل بعدی از حافظه.
- رمزگشایی دستورالعمل: تشخیص دستورالعمل و آماده‌سازی برای اجرا.
- ارسال سیگنال‌های کنترلی: کنترل جریان داده بین اجزای مسیر داده.
- کنترل واحدهای عملکردی مسیر داده: مدیریت عملیات واحدهایی مانند ALU.

### مسیر داده (Datapath):

مسیر داده وظیفه اجرای دستورالعمل‌ها را دارد. شامل:
- واحدهای عملکردی: مانند جمع‌کننده و فایل رجیسترها برای ذخیره داده‌ها.
- اتصالات داخلی: برای انتقال داده بین واحدها.
- دسترسی به حافظه: بارگذاری داده از حافظه و ذخیره آن در صورت نیاز.

## نرم‌افزار سیستمی (System Software):

### سیستم‌عامل (Operating System):

برنامه نظارتی: واسطه بین برنامه‌های کاربر و سخت‌افزار (مانند Linux، iOS، Windows).

وظایف اصلی:
- مدیریت ورودی و خروجی پایه.
- تخصیص حافظه و ذخیره‌سازی.
- ایجاد اشتراک‌گذاری امن بین چندین برنامه.

### کامپایلر (Compiler):

ترجمه برنامه‌های نوشته‌شده در زبان‌های سطح بالا (مانند C، Java) به دستورالعمل‌هایی که سخت‌افزار اجرا می‌کند.

### مزایای زبان‌های سطح بالا:

- زبان طبیعی‌تر: به برنامه‌نویس امکان می‌دهد به زبان طبیعی‌تر و متناسب با کاربرد فکر کند. مثال: Fortran برای محاسبات علمی، Cobol برای برنامه‌های تجاری، Java برای برنامه‌نویسی وب.
- افزایش بهره‌وری برنامه‌نویس: کد قابل‌فهم‌تر است و به راحتی اشکال‌زدایی و اعتبارسنجی می‌شود.
- بهبود نگهداری برنامه: کدهای سطح بالا معمولاً راحت‌تر تغییر و به‌روز می‌شوند.
- استقلال از سخت‌افزار: برنامه‌نویس نیازی به نگرانی در مورد معماری سخت‌افزاری ندارد؛ کامپایلرها و اسمبلرها زبان‌های سطح بالا را به دستورالعمل‌های ماشین تبدیل می‌کنند.
- کامپایلرهای بهینه‌ساز: کامپایلرها قادر به تولید کد اسمبلی بهینه برای سخت‌افزار هدف هستند.

نتیجه: امروزه برنامه‌نویسی در سطح اسمبلی به ندرت انجام می‌شود.

## جریان کامپایل سنتی (Traditional Compilation Flow):

برنامه C: برنامه توسط برنامه‌نویس نوشته می‌شود.
- کامپایلر: برنامه C را به زبان اسمبلی تبدیل می‌کند.
- اسمبلر: برنامه اسمبلی را به زبان ماشین (کد باینری) تبدیل می‌کند.
- روال‌های کتابخانه‌ای (Library Routines): کدهای آماده‌ای که به برنامه اضافه می‌شوند.
- لینکر (Linker): تمام بخش‌های کد (برنامه اصلی و کتابخانه‌ها) را ترکیب کرده و یک فایل اجرایی (Executable) تولید می‌کند.
- لودر (Loader): فایل اجرایی را در حافظه بارگذاری می‌کند تا اجرا شود.

## توضیح کلی:

سازمان پردازنده به کمک دو بخش کنترل و مسیر داده، دستورالعمل‌ها را مدیریت و اجرا می‌کند. نرم‌افزار سیستمی مانند سیستم‌عامل و کامپایلر نقش کلیدی در تسهیل تعامل برنامه‌های کاربر با سخت‌افزار دارند. زبان‌های سطح بالا به دلیل افزایش بهره‌وری و استقلال از سخت‌افزار، جایگزین کدنویسی در سطح اسمبلی شده‌اند. جریان سنتی کامپایل شامل ترجمه چند مرحله‌ای برنامه‌ها از زبان‌های سطح بالا به کد ماشین است که قابل اجرا روی سخت‌افزار باشد.

## پایین‌ترین سطح برنامه (Below the Program):

1. برنامه زبان سطح بالا (High-Level Language Program):

نمونه کد به زبان C برای جابجایی دو عنصر در آرایه:

</div>

<div dir="ltr">

```c
swap(int v[], int k) {
    int temp;
    temp = v[k];
    v[k] = v[k+1];
    v[k+1] = temp;
}
```

</div>

<div dir="rtl">

"one-to-many": به این معنا که یک دستور در زبان سطح بالا می‌تواند به چندین دستور اسمبلی ترجمه شود.

2. برنامه زبان اسمبلی (Assembly Language Program):

کد مربوط به تابع swap به زبان اسمبلی:

</div>

<div dir="ltr">

```assembly
swap:
    sll $2, $5, 2
    add $2, $4, $2
    lw $15, 0($2)
    lw $16, 4($2)
    sw $16, 0($2)
    sw $15, 4($2)
    jr $31
```

</div>

<div dir="rtl">

در این سطح، هر دستور زبان اسمبلی به یک دستور زبان ماشین (Machine Code) ترجمه می‌شود. این فرآیند توسط اسمبلر (Assembler) انجام می‌شود.

3. کد ماشین (Machine Code):

معادل باینری دستورات اسمبلی:

<div dir="ltr">

```plaintext
000000 00000 00101 0001000010000000
000000 00100 00010 0001000000100000
...
```

</div>

هر خط زبان اسمبلی یک کد ماشین باینری معادل (binary machine code) دارد. این کد برای پردازنده قابل فهم است.

## کد ماشین ذخیره شده در حافظه (Object Code Stored in Memory):

### نحوه عملکرد:

- کد ماشین در حافظه ذخیره می‌شود.
- پردازنده (Processor) دستورات را از حافظه بازیابی کرده و آنها را اجرا می‌کند.

### عناصر دخیل در این فرآیند:

- کنترل (Control): مدیریت اجرای دستورها.
- مسیر داده (Datapath): اجرا و پردازش دستورالعمل‌ها.
- حافظه: محلی برای ذخیره کد ماشین.
- ورودی و خروجی: دستگاه‌هایی مانند صفحه‌کلید و نمایشگر.

### فرآیند کلی:

- ورودی به کد ماشین: برنامه ورودی (مثلاً فایل اجرایی) شامل دستورالعمل‌های زبان ماشین است.
- ذخیره‌سازی در حافظه: کد ماشین در حافظه ذخیره شده و آماده اجرا می‌شود.
- بازیابی و اجرا توسط پردازنده: پردازنده، دستورالعمل‌ها را از حافظه بازیابی (Fetch) می‌کند. مسیر داده و کنترل، وظیفه اجرای این دستورالعمل‌ها را بر عهده دارند.
- تعامل با دستگاه‌ها: پردازنده، داده‌ها را به دستگاه‌های ورودی و خروجی ارسال کرده یا از آنها دریافت می‌کند.

## توضیحات تکمیلی:

فرآیند ترجمه از زبان سطح بالا به کد ماشین به کمک چندین مرحله انجام می‌شود:
- کامپایلر: زبان سطح بالا را به اسمبلی ترجمه می‌کند.
- اسمبلر: کد اسمبلی را به کد ماشین تبدیل می‌کند.
- لینکر و لودر: برنامه را به فایل اجرایی تبدیل و آن را در حافظه بارگذاری می‌کنند.

توجه: پردازنده تنها کد ماشین را اجرا می‌کند؛ بنابراین تمام مراحل بالا برای تبدیل کد نوشته‌شده توسط برنامه‌نویس به دستوری که پردازنده بتواند بفهمد ضروری است.

## Decode & Execute Codes (رمزگشایی و اجرای دستورالعمل‌ها):

### فرآیند رمزگشایی (Decode):

#### کنترل (Control):

کنترلر در پردازنده دستورالعملی که از حافظه گرفته شده است را رمزگشایی می‌کند تا بفهمد چه عملیاتی باید انجام شود.

مثال: کد ماشین زیر به این معنی است که:

<div dir="ltr">

```plaintext
000000 00100 00010 0001000000100000
```

</div>

عملیات:
- مقدار رجیستر ۴ (contents Reg #4) به مقدار رجیستر ۲ (contents Reg #2) اضافه می‌شود.
- نتیجه در رجیستر ۲ (Reg #2) ذخیره می‌شود.

### فرآیند اجرا (Execute):

#### مسیر داده (Datapath):

مسیر داده عملیات مشخص‌شده توسط کنترلر را اجرا می‌کند. شامل واحدهای محاسباتی (مانند ALU)، رجیسترها و اتصال بین آنها برای اجرای دستورالعمل‌ها است.

## What Happens Next? (چه اتفاقی می‌افتد؟):

### فرآیند کلی اجرا در پردازنده:

#### بازیابی (Fetch):

پردازنده دستورالعمل بعدی را از حافظه دریافت می‌کند.

سوال: پردازنده چگونه می‌داند دستورالعمل بعدی کجاست؟

پاسخ: پردازنده از شمارنده برنامه (Program Counter - PC) استفاده می‌کند که آدرس دستورالعمل فعلی را نگه می‌دارد و پس از هر دستورالعمل افزایش می‌یابد.

#### رمزگشایی (Decode):

کنترلر دستورالعمل را بررسی و تجزیه‌وتحلیل می‌کند. تعیین می‌کند که چه عملیاتی باید انجام شود و کدام واحدها (مانند ALU یا رجیسترها) درگیر باشند.

#### اجرا (Execute):

مسیر داده (Datapath) عملیات را انجام می‌دهد (مثلاً جمع، ضرب، بارگذاری داده از حافظه، ذخیره‌سازی داده در حافظه و غیره).

#### نوشتن نتیجه:

نتیجه عملیات در یک رجیستر یا حافظه ذخیره می‌شود.

## Output Device Outputs Data (خروجی داده‌ها توسط دستگاه خروجی):

پس از اجرای دستورالعمل‌ها، داده‌های خروجی از طریق دستگاه‌های خروجی (مانند نمایشگر، چاپگر، یا شبکه) ارائه می‌شوند.

### مثال کد ماشین برای تولید خروجی:

<div dir="ltr">

```plaintext
00000100010100000000000000000000
00000000010011110000000000000100
00000011111000000000000000001000
```

</div>

## توضیحات تکمیلی:

### ارتباط بین اجزا:

- کنترلر وظیفه هدایت مسیر داده را بر عهده دارد.
- مسیر داده شامل عملیات محاسباتی و ذخیره‌سازی است.
- حافظه محلی برای دستورالعمل‌ها و داده‌ها است.
- دستگاه‌های ورودی/خروجی تعامل با دنیای خارج را ممکن می‌کنند.

### مفهوم دستورالعمل‌ها:

دستورالعمل‌ها به سه مرحله اصلی تقسیم می‌شوند: بازیابی (Fetch)، رمزگشایی (Decode)، و اجرا (Execute). ارتباط صحیح بین این مراحل برای اجرای صحیح برنامه ضروری است.

## ISA - پل بین سخت‌افزار و نرم‌افزار

### تعریف معماری مجموعه دستورات (ISA):

ISA یا معماری مجموعه دستورات به عنوان رابط انتزاعی بین سخت‌افزار و پایین‌ترین سطح نرم‌افزار عمل می‌کند. شامل تمامی اطلاعاتی است که برای نوشتن یک برنامه به زبان ماشین نیاز است: دستورات، رجیسترها، دسترسی به حافظه، ورودی/خروجی، و غیره.

### ویژگی‌های ISA:

#### تطبیق‌پذیری:

ISA امکان اجرای نرم‌افزار یکسان روی سخت‌افزارهایی با هزینه و عملکرد متفاوت را فراهم می‌کند.

#### رابط دودویی برنامه‌ها (ABI):

ترکیب مجموعه دستورات پایه (ISA) و رابط سیستم‌عامل. شامل بخشی از مجموعه دستورات که کاربران استفاده می‌کنند و رابط‌های سیستم‌عامل برای برنامه‌نویسان. استانداردی برای قابلیت حمل دودویی (Binary Portability) بین کامپیوترها تعریف می‌کند.

### دو اصل کلیدی در طراحی ماشین:

#### نمایش دستورات به‌صورت اعداد:

دستورات به‌صورت اعداد ذخیره می‌شوند و از نظر سخت‌افزار، از داده‌ها قابل‌تشخیص نیستند. این موضوع اجرای دستورات را ساده‌تر و یکنواخت‌تر می‌کند.

#### ذخیره برنامه‌ها در حافظه قابل تغییر:

برنامه‌ها مانند داده‌ها در حافظه ذخیره و اجرا می‌شوند. این رویکرد که به آن مفهوم برنامه ذخیره‌شده (Stored-Program Concept) گفته می‌شود، باعث می‌شود:
- برنامه‌ها به‌صورت فایل‌های دودویی انتقال یابند.
- کامپیوترهای مختلف نرم‌افزارهای آماده را اجرا کنند، به شرطی که با ISA سازگار باشند.

### اهداف طراحی ISA:

- بهبود عملکرد
- کاهش هزینه
- کاهش زمان طراحی (Time-to-Market)
- بهینه‌سازی فضای حافظه (برای سیستم‌های تعبیه‌شده)
- کاهش مصرف توان (برای دستگاه‌های موبایل)

## RISC-V ISA - هدف طراحی ما

RISC-V یک معماری مجموعه دستورات مدرن است که از معماری‌های مشابهی که از دهه ۱۹۸۰ توسعه داده شده‌اند الهام گرفته است.

### ویژگی‌های کلیدی:

- ساده‌تر برای ساخت سخت‌افزار و کامپایلر.
- قابلیت افزایش عملکرد و کاهش هزینه.
- حداقل‌سازی مصرف توان و فضای حافظه.

### منشاء RISC-V:

از معماری MIPS نشات گرفته است. MIPS در محصولات شرکت‌هایی مانند Broadcom، Cisco، NEC، Nintendo، و Sony استفاده شده است.

### مفهوم ذخیره‌سازی برنامه:

برنامه‌ها و داده‌ها هر دو به‌صورت دودویی در حافظه ذخیره می‌شوند. نرم‌افزارهای آماده را می‌توان روی سخت‌افزارهای جدید اجرا کرد، اگر با ISA فعلی سازگار باشند. این رویکرد، صنعت را به سمت همگرایی روی تعداد کمی از ISA‌ها سوق داده است.

### دستورات زبان اسمبلی:

زبان ماشین: زبان ISA که توسط سخت‌افزار فهمیده و اجرا می‌شود.

#### ISA باید:

- ساخت سخت‌افزار و کامپایلر را آسان کند.
- عملکرد را به حداکثر برساند.
- هزینه را به حداقل برساند.

### RISC vs. CISC

#### CISC (Complex Instruction Set Computer):

ویژگی‌ها:
- تعداد زیادی دستورالعمل با اندازه‌های متغیر.
- بهینه برای استفاده از حافظه.
- معمولاً تعداد کمتری رجیستر دارد.
- مثال: معماری Intel x86.

#### RISC (Reduced Instruction Set Computer):

ویژگی‌ها:
- دستورالعمل‌ها با طول ثابت.
- رجیسترهای بیشتر.
- بهینه برای سرعت (بارگذاری و ذخیره در رجیسترها).
- غالباً به‌عنوان معماری "Load/Store" شناخته می‌شود.
- مثال‌ها: RISC-V، LC-3b، MIPS، ARM، Sun SPARC، HP PA-RISC، IBM PowerPC.

### تاریخچه MIPS:

معماری MIPS در بسیاری از سیستم‌های تعبیه‌شده استفاده شده است. مثال‌ها: Nintendo-64، Playstation 1، Playstation 2.

### فلسفه طراحی RISC:

#### طراحی ساده‌تر:

- طول ثابت برای دستورالعمل‌ها.
- مجموعه دستورالعمل‌های Load/Store.
- تعداد محدود حالت‌های آدرس‌دهی.
- تعداد محدود عملیات.

#### هدف اصلی:

مجموعه دستورالعمل‌ها باید برای کامپایلرها مناسب باشد، نه فقط برای برنامه‌نویسان زبان اسمبلی.

### اصول طراحی RISC-V:

1. سادگی باعث یکنواختی می‌شود:
   - اندازه ثابت دستورال