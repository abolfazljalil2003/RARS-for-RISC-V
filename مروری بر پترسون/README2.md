# مبانی کامپیوتر و معماری ISA

<div dir="rtl">

## 📑 فهرست مطالب

- [کامپیوتر چیست؟](#کامپیوتر-چیست)
- [اجزای اصلی کامپیوتر](#اجزای-اصلی-کامپیوتر)
- [سازمان ماشین](#سازمان-ماشین)
- [سازمان پردازنده](#سازمان-پردازنده)
- [نرم‌افزار سیستمی](#نرم‌افزار-سیستمی)
- [جریان کامپایل](#جریان-کامپایل)
- [پایین‌ترین سطح برنامه](#پایین‌ترین-سطح-برنامه)
- [فرآیند اجرای دستورات](#فرآیند-اجرای-دستورات)
- [معماری ISA](#معماری-isa)
- [RISC vs CISC](#risc-vs-cisc)
- [معرفی RISC-V](#معرفی-risc-v)

---

## کامپیوتر چیست؟

### 🖥️ اجزای اصلی

یک کامپیوتر شامل اجزای کلیدی زیر است:

<div dir="ltr">

```
┌─────────────────────────────────────┐
│           Computer System           │
├─────────────────────────────────────┤
│  ┌───────────────────────────────┐  │
│  │        Processor (CPU)        │  │
│  │  ┌─────────┬──────────────┐   │  │
│  │  │Datapath │   Control    │   │  │
│  │  └─────────┴──────────────┘   │  │
│  └───────────────────────────────┘  │
│                                     │
│  ┌───────────────────────────────┐  │
│  │      Memory Hierarchy         │  │
│  │  Cache → Main → Storage       │  │
│  └───────────────────────────────┘  │
│                                     │
│  ┌───────────┐    ┌──────────────┐ │
│  │   Input   │    │    Output    │ │
│  │  Devices  │    │   Devices    │ │
│  └───────────┘    └──────────────┘ │
│                                     │
│  ┌───────────────────────────────┐  │
│  │          Network              │  │
│  └───────────────────────────────┘  │
└─────────────────────────────────────┘
```

</div>

### 🔧 پردازنده (Processor)

پردازنده شامل دو بخش اصلی است:

#### 1. مسیر داده (Datapath)

**وظیفه:**
- انتقال و پردازش داده
- اجرای عملیات محاسباتی
- مدیریت جریان داده بین اجزا

**اجزای کلیدی:**

<div dir="ltr">

```
┌──────────────────┐
│    Registers     │ ← ذخیره موقت داده
└────────┬─────────┘
         │
         ▼
    ┌────────┐
    │  ALU   │      ← واحد محاسباتی
    └────┬───┘
         │
         ▼
    ┌────────┐
    │ Result │      ← نتیجه عملیات
    └────────┘
```

</div>

#### 2. واحد کنترل (Control)

**وظایف:**
- مدیریت اجرای دستورات
- هدایت مسیر داده
- تولید سیگنال‌های کنترلی
- کنترل واحدهای عملکردی

### 💾 حافظه (Memory)

**سلسله‌مراتب حافظه:**

<div dir="ltr">

| سطح | نوع | سرعت | ظرفیت | قیمت |
|-----|-----|------|--------|------|
| **L1 Cache** | سریع‌ترین | ~1 cycle | KB | خیلی گران |
| **L2 Cache** | سریع | ~10 cycles | MB | گران |
| **Main Memory** | متوسط | ~100 cycles | GB | متوسط |
| **Storage** | کند | ~10ms | TB | ارزان |

</div>

**انواع حافظه:**

1. **حافظه کش (Cache)**
   - نزدیک‌ترین به پردازنده
   - دسترسی بسیار سریع
   - ذخیره داده‌های پرتکرار

2. **حافظه اصلی (Main Memory)**
   - RAM
   - ذخیره برنامه‌ها و داده‌های فعال

3. **حافظه ذخیره‌سازی (Storage)**
   - دیسک سخت، SSD
   - ذخیره طولانی‌مدت

### 🔌 ورودی/خروجی (I/O)

**دستگاه‌های ورودی:**
- صفحه‌کلید
- ماوس
- میکروفون
- دوربین
- سنسورها

**دستگاه‌های خروجی:**
- صفحه‌نمایش
- چاپگر
- بلندگو
- LED

### 🌐 شبکه (Network)

**کاربرد:**
- اتصال به اینترنت
- ارتباط بین کامپیوترها
- اشتراک‌گذاری منابع

---

## اجزای اصلی کامپیوتر

### 📊 سه لایه اصلی

<div dir="ltr">

```
┌─────────────────────────────────┐
│   Applications (برنامه‌های     │
│        کاربردی)                │
│  Text Editors, Music Players,  │
│  Web Browsers, Games           │
└────────────┬────────────────────┘
             │
┌────────────▼────────────────────┐
│   Operating System              │
│      (سیستم‌عامل)               │
│  • Kernel (هسته)                │
│  • File Systems                 │
│  • Device Drivers               │
│  • Security & GUI               │
└────────────┬────────────────────┘
             │
┌────────────▼────────────────────┐
│   Hardware (سخت‌افزار)          │
│  Processor, Memory, Storage,   │
│  Display, Network Adapter      │
└─────────────────────────────────┘
```

</div>

### 1️⃣ برنامه‌های کاربردی (Applications)

**نمونه‌ها:**
- ویرایشگرهای متن
- پخش‌کننده‌های موسیقی و ویدیو
- مرورگرهای وب
- بازی‌ها
- نرم‌افزارهای اداری

### 2️⃣ سیستم‌عامل (Operating System)

**وظایف اصلی:**

<div dir="ltr">

| بخش | وظیفه |
|-----|-------|
| **Kernel** | هسته اصلی سیستم‌عامل |
| **File Systems** | مدیریت فایل‌ها |
| **Device Drivers** | ارتباط با سخت‌افزار |
| **Security** | امنیت سیستم |
| **GUI/API** | رابط کاربری |

</div>

**مسئولیت‌ها:**
- مدیریت ورودی و خروجی پایه
- تخصیص حافظه و ذخیره‌سازی
- اشتراک‌گذاری امن بین برنامه‌ها
- زمان‌بندی پردازنده

### 3️⃣ سخت‌افزار (Hardware)

**اجزای کلیدی:**
- پردازنده (CPU)
- حافظه (RAM)
- ذخیره‌سازی (Hard Drive, SSD)
- نمایشگر
- آداپتور شبکه
- دستگاه‌های ورودی/خروجی

---

## سازمان ماشین

### 🏗️ Machine Organization

**مفهوم:**
> نحوه سازماندهی و اتصال اجزای سخت‌افزاری برای تشکیل یک سیستم کامل

### 🔩 واحدهای عملکردی (Functional Units)

**اجزای اصلی:**

<div dir="ltr">

```
┌────────────────────────────────┐
│    Functional Units (FUs)      │
├────────────────────────────────┤
│  • Register File               │
│  • ALU (Arithmetic Logic Unit) │
│  • Multiplexers                │
│  • Memory Units                │
│  • Control Logic               │
└────────────────────────────────┘
```

</div>

**ویژگی‌های هر واحد:**
- قابلیت‌های عملکردی خاص
- رابط‌های ورودی/خروجی مشخص
- زمان‌بندی عملیات

### 🔗 اتصالات بین واحدها

**باس‌ها (Buses):**

<div dir="ltr">

```
    FU1 ─────┬───── Bus ─────┬───── FU2
             │               │
             └───── FU3 ─────┘

Types:
• Data Bus:    انتقال داده
• Address Bus: انتقال آدرس
• Control Bus: سیگنال‌های کنترلی
```

</div>

### 🎛️ کنترل جریان اطلاعات

**مکانیزم‌ها:**
- سیگنال‌های کنترلی
- مالتی‌پلکسرها
- زمان‌بندی
- همگام‌سازی کلاک

### 📐 ISA - Instruction Set Architecture

**تعریف:**
> مجموعه دستورات و عملیات‌هایی که پردازنده پشتیبانی می‌کند

**شامل:**
- دستورات
- رجیسترها
- حالت‌های آدرس‌دهی
- دسترسی به حافظه
- ورودی/خروجی

### 📝 RTL - Register Transfer Level

**مفهوم:**
> توصیف رفتار کامپیوتر در سطح عملیات رجیسترها

**مثال:**

<div dir="ltr">

```
RTL Description:

R1 ← R2 + R3
// محتوای R2 و R3 جمع شده و در R1 ذخیره می‌شود

PC ← PC + 4
// شمارنده برنامه 4 واحد افزایش می‌یابد
```

</div>

---

## سازمان پردازنده

### 🎮 Processor Organization

<div dir="ltr">

```
┌─────────────────────────────────┐
│         Processor               │
├─────────────────────────────────┤
│  ┌──────────┐  ┌─────────────┐  │
│  │ Control  │  │  Datapath   │  │
│  └─────┬────┘  └──────┬──────┘  │
│        │              │         │
│        └──── Signals ─┘         │
└─────────────────────────────────┘
```

</div>

### 🎛️ کنترل (Control)

**وظایف:**

1. **انتخاب دستور بعدی**
   - مدیریت Program Counter
   - پیش‌بینی انشعاب
   - محاسبه آدرس دستور

2. **رمزگشایی دستورالعمل**
   - تجزیه Opcode
   - شناسایی عملوندها
   - تعیین نوع دستور

3. **ارسال سیگنال‌های کنترلی**

<div dir="ltr">

```
Control Signals:
• ALUOp:      نوع عملیات ALU
• RegWrite:   نوشتن در رجیستر
• MemRead:    خواندن از حافظه
• MemWrite:   نوشتن در حافظه
• Branch:     دستور انشعاب
```

</div>

4. **کنترل واحدهای عملکردی**
   - هماهنگی بین اجزا
   - زمان‌بندی عملیات

### ⚙️ مسیر داده (Datapath)

**وظایف:**

1. **اجرای دستورالعمل‌ها**

<div dir="ltr">

```
Execution Flow:

Read Operands → ALU Operation → Write Result

     ┌──────────┐
     │ Register │
     │   File   │
     └────┬─────┘
          │
          ▼
     ┌────────┐
     │  ALU   │
     └────┬───┘
          │
          ▼
     ┌────────┐
     │ Result │
     └────────┘
```

</div>

2. **واحدهای عملکردی**
   - جمع‌کننده (Adder)
   - ALU
   - فایل رجیسترها
   - مالتی‌پلکسرها

3. **اتصالات داخلی**
   - باس‌های داده
   - خطوط کنترل
   - مسیرهای Forwarding

4. **دسترسی به حافظه**
   - بارگذاری (Load)
   - ذخیره (Store)
   - مدیریت کش

---

## نرم‌افزار سیستمی

### 🖥️ System Software

### 1️⃣ سیستم‌عامل (Operating System)

**تعریف:**
> برنامه نظارتی که واسطه بین برنامه‌های کاربر و سخت‌افزار است

**نمونه‌ها:**
- Linux
- Windows
- macOS
- iOS
- Android

**وظایف اصلی:**

<div dir="ltr">

| وظیفه | توضیح |
|-------|-------|
| **I/O Management** | مدیریت ورودی/خروجی |
| **Memory Allocation** | تخصیص حافظه |
| **Storage Management** | مدیریت ذخیره‌سازی |
| **Process Management** | مدیریت فرآیندها |
| **Security** | امنیت سیستم |
| **Resource Sharing** | اشتراک‌گذاری منابع |

</div>

**مدیریت چندبرنامه‌ای:**

<div dir="ltr">

```
Multiple Programs:

Process 1  ─────┐
Process 2  ─────┼──► OS Scheduler ──► CPU
Process 3  ─────┤
Process 4  ─────┘

اشتراک‌گذاری امن و کارآمد منابع
```

</div>

### 2️⃣ کامپایلر (Compiler)

**وظیفه:**
> ترجمه برنامه‌های زبان سطح بالا به دستورالعمل‌های ماشین

**فرآیند:**

<div dir="ltr">

```
High-Level Language (C, Java, Python)
           ↓
       Compiler
           ↓
   Assembly Language
           ↓
       Assembler
           ↓
    Machine Code
```

</div>

### 💡 مزایای زبان‌های سطح بالا

#### 1. زبان طبیعی‌تر

**مثال‌ها:**

<div dir="ltr">

| زبان | کاربرد |
|------|--------|
| **Fortran** | محاسبات علمی |
| **Cobol** | برنامه‌های تجاری |
| **Java** | برنامه‌نویسی وب |
| **Python** | علم داده، AI |
| **C/C++** | سیستم‌ها، بازی‌ها |

</div>

#### 2. افزایش بهره‌وری برنامه‌نویس

<div dir="ltr">

```assembly
# Assembly (پیچیده):
lw   $t0, 0($s0)
addi $t0, $t0, 1
sw   $t0, 0($s0)

# vs

# C (ساده):
array[i]++;
```

</div>

**مزایا:**
- کد قابل‌فهم‌تر
- اشکال‌زدایی آسان‌تر
- توسعه سریع‌تر

#### 3. بهبود نگهداری برنامه

**ویژگی‌ها:**
- خوانایی بهتر
- مستندسازی آسان‌تر
- تغییرات ساده‌تر
- کار تیمی بهتر

#### 4. استقلال از سخت‌افزار

**مفهوم:**

<div dir="ltr">

```
       Same Code
           │
    ┌──────┼──────┐
    │      │      │
    ▼      ▼      ▼
  x86   ARM   RISC-V

کامپایلر برای هر معماری کد مناسب تولید می‌کند
```

</div>

**مزایا:**
- قابلیت حمل کد
- عدم وابستگی به معماری
- توسعه چندپلتفرمی

#### 5. کامپایلرهای بهینه‌ساز

**قابلیت‌ها:**
- تولید کد بهینه
- بهبود عملکرد
- کاهش مصرف حافظه
- بهینه‌سازی انرژی

**نتیجه:**
> امروزه برنامه‌نویسی در سطح اسمبلی به ندرت انجام می‌شود

---

## جریان کامپایل

### 🔄 Traditional Compilation Flow

<div dir="ltr">

```
┌──────────────────┐
│   C Program      │  ← برنامه نوشته‌شده
└────────┬─────────┘
         │
         ▼
┌──────────────────┐
│    Compiler      │  ← ترجمه به اسمبلی
└────────┬─────────┘
         │
         ▼
┌──────────────────┐
│ Assembly Program │  ← کد اسمبلی
└────────┬─────────┘
         │
         ▼
┌──────────────────┐
│    Assembler     │  ← ترجمه به ماشین
└────────┬─────────┘
         │
         ▼
┌──────────────────┐
│  Object Code     │  ← کد ماشین
└────────┬─────────┘
         │
         ├──────────┐
         │          │
         ▼          ▼
┌──────────┐   ┌─────────────┐
│ Linker   │◄──│  Libraries  │
└─────┬────┘   └─────────────┘
      │
      ▼
┌──────────────────┐
│   Executable     │  ← فایل اجرایی
└────────┬─────────┘
         │
         ▼
┌──────────────────┐
│     Loader       │  ← بارگذاری در حافظه
└────────┬─────────┘
         │
         ▼
┌──────────────────┐
│    Execution     │  ← اجرا
└──────────────────┘
```

</div>

### 📝 مراحل تفصیلی

#### 1. Compiler (کامپایلر)

**ورودی:**

<div dir="ltr">

```c
// C Code
int sum(int a, int b) {
    return a + b;
}
```

</div>

**خروجی:**

<div dir="ltr">

```assembly
# Assembly Code
sum:
    add a0, a0, a1
    ret
```

</div>

#### 2. Assembler (اسمبلر)

**ورودی:** کد اسمبلی  
**خروجی:** کد ماشین (Object Code)

<div dir="ltr">

```
Assembly:  add a0, a0, a1
           ↓
Machine:   0x00B50533
```

</div>

#### 3. Linker (لینکر)

**وظایف:**
- ترکیب Object Files
- اتصال به کتابخانه‌ها
- حل مراجع خارجی
- ایجاد فایل اجرایی

<div dir="ltr">

```
Object1.o ──┐
            ├──► Linker ──► Executable
Object2.o ──┤
            │
Library ────┘
```

</div>

#### 4. Loader (لودر)

**وظایف:**
- بارگذاری در حافظه
- تخصیص آدرس
- مقداردهی اولیه
- شروع اجرا

---

## پایین‌ترین سطح برنامه

### 📊 Below the Program

### 1️⃣ برنامه زبان سطح بالا

**مثال: تابع Swap در C**

<div dir="ltr">

```c
void swap(int v[], int k) {
    int temp;
    temp = v[k];
    v[k] = v[k+1];
    v[k+1] = temp;
}
```

</div>

**ویژگی:**
> "one-to-many": یک دستور سطح بالا → چند دستور اسمبلی

### 2️⃣ برنامه زبان اسمبلی

**ترجمه Swap به RISC-V:**

<div dir="ltr">

```assembly
swap:
    sll  x6, x11, 2     # x6 = k × 4
    add  x6, x10, x6    # x6 = &v[k]
    lw   x5, 0(x6)      # x5 = v[k]
    lw   x7, 4(x6)      # x7 = v[k+1]
    sw   x7, 0(x6)      # v[k] = x7
    sw   x5, 4(x6)      # v[k+1] = x5
    ret                 # return
```

</div>

**توضیح دستورات:**

<div dir="ltr">

| دستور | عملیات |
|-------|--------|
| `sll` | Shift Left Logical |
| `add` | جمع |
| `lw` | Load Word |
| `sw` | Store Word |
| `ret` | Return |

</div>

### 3️⃣ کد ماشین

**معادل باینری:**

<div dir="ltr">

```
Assembly:   sll x6, x11, 2
Binary:     00000000001001011001001100110011

Assembly:   add x6, x10, x6
Binary:     00000000011001010000001100110011

Assembly:   lw x5, 0(x6)
Binary:     00000000000000110010001010000011

...
```

</div>

**ساختار:**

<div dir="ltr">

```
32-bit Instruction:
┌────────┬────┬────┬────┬────┬────────┐
│ opcode │ rd │ f3 │ rs1│ rs2│ funct7 │
└────────┴────┴────┴────┴────┴────────┘
```

</div>

### 4️⃣ کد ماشین در حافظه

**ذخیره‌سازی:**

<div dir="ltr">

```
Memory Address    Machine Code
─────────────────────────────────
0x00001000:      00000000001001011001001100110011
0x00001004:      00000000011001010000001100110011
0x00001008:      00000000000000110010001010000011
0x0000100C:      00000000010000110010001110000011
0x00001010:      00000000011100110010000000100011
0x00001014:      00000000010100110010001000100011
0x00001018:      00000000000000000000000001100111
```

</div>

**فرآیند اجرا:**

<div dir="ltr">

```
   ┌────────────┐
   │   Memory   │
   └──────┬─────┘
          │
          ▼
   ┌────────────┐
   │   Fetch    │  ← واکشی دستور
   └──────┬─────┘
          │
          ▼
   ┌────────────┐
   │   Decode   │  ← رمزگشایی
   └──────┬─────┘
          │
          ▼
   ┌────────────┐
   │  Execute   │  ← اجرا
   └────────────┘
```

</div>

---

## فرآیند اجرای دستورات

### 🔄 Decode & Execute

### 1️⃣ رمزگشایی (Decode)

**مثال دستور:**

<div dir="ltr">

```
Machine Code:
00000000011001010000001100110011

Decode:
┌────────────────────────────────┐
│ Opcode:  0110011  (R-type)     │
│ rd:      00011    (x3)         │
│ funct3:  000      (ADD)        │
│ rs1:     00101    (x5)         │
│ rs2:     00110    (x6)         │
│ funct7:  0000000  (ADD)        │
└────────────────────────────────┘

Operation: x3 = x5 + x6
```

</div>

**کنترلر:**
- شناسایی نوع دستور
- استخراج عملوندها
- تولید سیگنال‌های کنترلی

### 2️⃣ اجرا (Execute)

**مسیر داده:**

<div dir="ltr">

```
Step 1: Read Registers
   RF[x5] = 10
   RF[x6] = 5

Step 2: ALU Operation
   Result = 10 + 5 = 15

Step 3: Write Back
   RF[x3] = 15
```

</div>

### 🔄 What Happens Next?

**چرخه Fetch-Decode-Execute:**

<div dir="ltr">

```
┌─────────┐
│  Fetch  │  PC → Memory → IR
└────┬────┘
     │
     ▼
┌─────────┐
│ Decode  │  IR → Control Signals
└────┬────┘
     │
     ▼
┌─────────┐
│ Execute │  ALU/Memory Operation
└────┬────┘
     │
     ▼
┌─────────┐
│ Write   │  Result → Register/Memory
└────┬────┘
     │
     └──────► Next Instruction
```

</div>

### 📍 Program Counter (PC)

**نقش:**
> نگهداری آدرس دستور فعلی

<div dir="ltr">

```
Cycle 1:  PC = 0x1000  →  Fetch instruction at 0x1000
Cycle 2:  PC = 0x1004  →  Fetch instruction at 0x1004
Cycle 3:  PC = 0x1008  →  Fetch instruction at 0x1008
...

PC = PC + 4  (هر دستور 4 بایت)
```

</div>

### 🖨️ خروجی (Output)

**مثال دستورات خروجی:**

<div dir="ltr">

```
Output Instructions:
00000100010100000000000000000000  ← تنظیم آدرس
00000000010011110000000000000100  ← ارسال داده
00000011111000000000000000001000  ← نمایش خروجی
```

</div>

**پس از اجرا:**
- داده‌های پردازش‌شده به دستگاه خروجی ارسال می‌شوند
- نمایشگر، چاپگر، یا شبکه خروجی را نمایش می‌دهند

---

## معماری ISA

### 🌉 ISA - پل بین سخت‌افزار و نرم‌افزار

### تعریف ISA

**Instruction Set Architecture:**

> رابط انتزاعی بین سخت‌افزار و پایین‌ترین سطح نرم‌افزار

<div dir="ltr">

```
┌─────────────────────────────┐
│   Software (High Level)     │
├─────────────────────────────┤
│   Compiler                  │
├─────────────────────────────┤
│   ISA Interface            │ ◄── پل ارتباطی
├─────────────────────────────┤
│   Hardware Implementation   │
└─────────────────────────────┘
```

</div>

### 📋 شامل چه مواردی است؟

**ISA تعریف می‌کند:**

<div dir="ltr">

| جزء | توضیح |
|-----|-------|
| **Instructions** | دستورات قابل اجرا |
| **Registers** | رجیسترهای قابل دسترس |
| **Memory Access** | نحوه دسترسی به حافظه |
| **I/O** | ورودی/خروجی |
| **Data Types** | انواع داده |
| **Addressing Modes** | حالت‌های آدرس‌دهی |

</div>

### 🔄 ویژگی تطبیق‌پذیری

**مفهوم:**

<div dir="ltr">

```
        Same ISA
           │
    ┌──────┼──────┐
    │      │      │
    ▼      ▼      ▼
  Low    Medium  High
  Cost    Cost   Cost
  Low    Medium  High
 Perf    Perf   Perf

نرم‌افزار یکسان روی همه اجرا می‌شود!
```

</div>

**مزیت:**
- سازگاری نرم‌افزاری
- انتخاب سخت‌افزار متناسب با بودجه
- عملکرد مقیاس‌پذیر

### 🔗 ABI - Application Binary Interface

**تعریف:**
> ترکیب ISA + رابط سیستم‌عامل

**شامل:**
- دستورات سطح کاربر
- System Calls
- کنوانسیون‌های فراخوانی
- فرمت فایل‌های اجرایی

**اهمیت:**

<div dir="ltr">

```
ABI = استاندارد قابلیت حمل دودویی

Program.exe (x86) ───► فقط روی x86 اجرا می‌شود
Program.exe (ARM) ───► فقط روی ARM اجرا می‌شود

Binary Portability مهم است!
```

</div>

### 🎯 دو اصل کلیدی طراحی

#### 1. نمایش دستورات به‌صورت اعداد

**مفهوم:**

<div dir="ltr">

```
Instruction = Number

add x1, x2, x3  →  0x003100B3

┌────────────────────────┐
│  برای سخت‌افزار:       │
│  دستور = داده = عدد    │
└────────────────────────┘
```

</div>

**مزایا:**
- ساده‌سازی سخت‌افزار
- یکنواختی در پردازش
- امکان خواندن/نوشتن دستورات

#### 2. برنامه‌های ذخیره‌شده

**Stored-Program Concept:**

<div dir="ltr">

```
Memory:
┌──────────────┐
│ Instructions │ ◄── برنامه
├──────────────┤
│     Data     │ ◄── داده
└──────────────┘

هر دو در حافظه قابل تغییر
```

</div>

**مزایا:**
- انتقال آسان برنامه‌ها
- بارگذاری از دیسک
- تغییر پویای برنامه
- اشتراک‌گذاری کد

### 🎨 اهداف طراحی ISA

**معیارهای کلیدی:**

<div dir="ltr">

| هدف | اهمیت | استراتژی |
|-----|-------|----------|
| **Performance** | بالا | Pipeline, Cache |
| **Cost** | بالا | Simple HW |
| **Time-to-Market** | متوسط | Standard ISA |
| **Memory Space** | در Embedded | Compact Code |
| **Power** | در Mobile | Low Power Design |

</div>

**تعادل:**

<div dir="ltr">

```
Performance ←───→ Cost
     ↕
   Power
```

</div>

---

## RISC vs CISC

### 🔍 مقایسه دو فلسفه طراحی

### 💻 CISC - Complex Instruction Set Computer

**ویژگی‌های کلیدی:**

<div dir="ltr">

| ویژگی | توضیح |
|-------|-------|
| **Instructions** | تعداد زیاد، پیچیده |
| **Length** | متغیر (1-17 بایت) |
| **Registers** | تعداد کم |
| **Memory Access** | هر دستور می‌تواند به حافظه دسترسی داشته باشد |
| **Goal** | کد فشرده، بهینه برای حافظه |

</div>

**مثال: Intel x86**

<div dir="ltr">

```assembly
# یک دستور CISC می‌تواند:
add [eax], ebx    # خواندن از حافظه + جمع + نوشتن

# معادل چند دستور RISC:
lw   t0, 0(a0)    # خواندن
add  t0, t0, a1   # جمع
sw   t0, 0(a0)    # نوشتن
```

</div>

**مزایا:**
- کد کوتاه‌تر
- استفاده کمتر از حافظه
- سازگاری با گذشته

**معایب:**
- پیچیدگی سخت‌افزار
- اجرای کندتر دستورات پیچیده
- مصرف انرژی بیشتر

### ⚡ RISC - Reduced Instruction Set Computer

**ویژگی‌های کلیدی:**

<div dir="ltr">

| ویژگی | توضیح |
|-------|-------|
| **Instructions** | تعداد کم، ساده |
| **Length** | ثابت (32 بیت) |
| **Registers** | تعداد زیاد (32) |
| **Memory Access** | فقط Load/Store |
| **Goal** | سرعت بالا، سادگی |

</div>

**مثال‌ها:**
- RISC-V
- ARM
- MIPS
- SPARC
- PowerPC

**معماری Load/Store:**

<div dir="ltr">

```
┌─────────────────────────────┐
│   Only Load/Store Access    │
│   Memory                    │
└─────────────────────────────┘
         ↕
┌─────────────────────────────┐
│   All Other Operations      │
│   Use Registers             │
└─────────────────────────────┘
```

</div>

**مزایا:**
- اجرای سریع
- Pipeline ساده‌تر
- مصرف انرژی کمتر
- طراحی ساده‌تر

**معایب:**
- کد طولانی‌تر
- نیاز به حافظه بیشتر برای دستورات

### 📊 جدول مقایسه

<div dir="ltr">

| معیار | CISC (x86) | RISC (RISC-V) |
|-------|------------|---------------|
| **تعداد دستورات** | 500+ | ~50 |
| **طول دستور** | 1-17 byte | 32 bit |
| **رجیسترها** | 8-16 | 32 |
| **حافظه** | هر دستور | Load/Store فقط |
| **Pipeline** | پیچیده | ساده |
| **کد** | فشرده | طولانی‌تر |
| **سرعت** | متوسط | بالا |
| **انرژی** | بیشتر | کمتر |

</div>

### 📈 تاریخچه MIPS

**MIPS در محصولات:**

<div dir="ltr">

```
┌─────────────────────────────┐
│   MIPS در تاریخ            │
├─────────────────────────────┤
│ • Broadcom (شبکه)           │
│ • Cisco (روترها)            │
│ • NEC (الکترونیک)           │
│ • Nintendo (N64)            │
│ • Sony (PS1, PS2)           │
└─────────────────────────────┘
```

</div>

**تأثیر:**
- الهام‌بخش RISC-V
- مفاهیم کلیدی RISC
- معماری آموزشی محبوب

---

## معرفی RISC-V

### 🌟 RISC-V ISA - معماری باز

### 🆓 ویژگی‌های کلیدی

**1. استاندارد باز (Open Standard)**

<div dir="ltr">

```
┌─────────────────────────────┐
│   RISC-V = Open & Free      │
├─────────────────────────────┤
│ ✓ No License Fees           │
│ ✓ No Royalties              │
│ ✓ Open Specification        │
│ ✓ Community Driven          │
└─────────────────────────────┘
```

</div>

**مقایسه:**

<div dir="ltr">

| معماری | نوع | مالک |
|--------|-----|------|
| **x86** | اختصاصی | Intel/AMD |
| **ARM** | اختصاصی | ARM Ltd |
| **MIPS** | اختصاصی | Wave Computing |
| **RISC-V** | باز | RISC-V Foundation |

</div>

**2. مدیریت توسط RISC-V Foundation**

**اعضا (تا 2020):**
- بیش از 200 شرکت
- دانشگاه‌ها
- محققان مستقل

**شرکت‌های معروف:**
- Google
- NVIDIA
- Western Digital
- Samsung
- Alibaba

### 🏗️ ساختار مدولار

**Base + Extensions:**

<div dir="ltr">

```
┌──────────────────────────────┐
│   RV32I (Base Integer)       │  ← اجباری
└──────────────┬───────────────┘
               │
       ┌───────┼───────┐
       ▼       ▼       ▼
    ┌────┐ ┌────┐ ┌────┐
    │ M  │ │ A  │ │ F  │        ← اختیاری
    └────┘ └────┘ └────┘
     ضرب    Atomic  Float
```

</div>

**پسوندهای استاندارد:**

<div dir="ltr">

| پسوند | نام | کاربرد |
|-------|-----|--------|
| **I** | Integer | دستورات پایه |
| **M** | Multiply | ضرب/تقسیم |
| **A** | Atomic | عملیات اتمی |
| **F** | Float | ممیز شناور |
| **D** | Double | دقت دوگانه |
| **C** | Compressed | دستورات فشرده |

</div>

**ترکیب‌های رایج:**

<div dir="ltr">

```
RV32I:     پایه (32-bit)
RV32IM:    پایه + ضرب/تقسیم
RV32G:     پایه + M + A + F + D (General)
RV64G:     64-bit General
```

</div>

### 🎯 فلسفه طراحی RISC-V

#### 1. سادگی → یکنواختی

**دستورات:**

<div dir="ltr">

```
Fixed 32-bit Instructions:

┌────────────────────────────┐
│  Every instruction = 32bit │
└────────────────────────────┘

┌──────┬─────┬─────┬──────────┐
│ 6bit │ ... │ ... │   ...    │
│ OP   │     │     │          │
└──────┴─────┴─────┴──────────┘
      همیشه اینجا
```

</div>

**فرمت‌ها:**
- تعداد کم (6 نوع)
- ساختار مشابه
- Opcode همیشه در همان جا

#### 2. کوچکتر → سریع‌تر

**محدودیت‌ها:**

<div dir="ltr">

```
✓ ~50 دستور پایه
✓ 32 رجیستر
✓ حالت‌های آدرس‌دهی محدود
✓ عملیات ساده

Result: سخت‌افزار سریع‌تر و کم‌مصرف‌تر
```

</div>

#### 3. رایج‌ترین → سریع‌تر

**بهینه‌سازی:**

<div dir="ltr">

```
Common Case:
• عملوندها از رجیستر  ✓
• مقادیر Immediate کوچک ✓
• دسترسی متوالی به حافظه ✓

Uncommon Case:
• ثابت‌های بزرگ
• پرش‌های دور
```

</div>

#### 4. طراحی خوب = مصالحه مناسب

**تعادل:**

<div dir="ltr">

```
Performance ←─── Trade-off ───→ Simplicity
     ↑                              ↑
  Pipeline                    Less Hardware
   Better                      Lower Cost
```

</div>

**در RISC-V:**
- 4 فرمت اصلی (R/I/S/U)
- 2 فرمت افزوده (B/J)
- کافی برای انعطاف
- ساده برای پیاده‌سازی

### 📚 دسته‌بندی دستورات RISC-V

**انواع دستورات:**

<div dir="ltr">

```
┌────────────────────────────────┐
│   RISC-V Instructions          │
├────────────────────────────────┤
│ 1. Load/Store                  │
│    lw, sw, lb, sb              │
├────────────────────────────────┤
│ 2. Arithmetic                  │
│    add, sub, addi, mul         │
├────────────────────────────────┤
│ 3. Bitwise                     │
│    and, or, xor, sll, srl      │
├────────────────────────────────┤
│ 4. Control Transfer            │
│    beq, bne, jal, jalr         │
├────────────────────────────────┤
│ 5. Pseudo Instructions         │
│    mv, li, la, nop             │
└────────────────────────────────┘
```

</div>

#### 1. Load/Store

<div dir="ltr">

```assembly
lw   t0, 0(sp)    # Load Word
sw   t0, 4(sp)    # Store Word
lb   t0, 0(a0)    # Load Byte
sb   t0, 0(a1)    # Store Byte
```

</div>

#### 2. Arithmetic

<div dir="ltr">

```assembly
add  t0, t1, t2   # t0 = t1 + t2
sub  t0, t1, t2   # t0 = t1 - t2
addi t0, t1, 10   # t0 = t1 + 10
mul  t0, t1, t2   # t0 = t1 × t2
```

</div>

#### 3. Bitwise

<div dir="ltr">

```assembly
and  t0, t1, t2   # t0 = t1 & t2
or   t0, t1, t2   # t0 = t1 | t2
xor  t0, t1, t2   # t0 = t1 ^ t2
sll  t0, t1, 2    # t0 = t1 << 2
```

</div>

#### 4. Control Transfer

<div dir="ltr">

```assembly
beq  t0, t1, label  # if (t0 == t1) goto label
bne  t0, t1, label  # if (t0 != t1) goto label
jal  ra, function   # call function
jalr ra, 0(t0)      # indirect jump
```

</div>

#### 5. Pseudo Instructions

<div dir="ltr">

```assembly
mv   t0, t1        # t0 = t1 (move)
li   t0, 100       # t0 = 100 (load immediate)
la   t0, label     # t0 = address(label)
nop                # no operation
```

</div>

### 🚀 چرا RISC-V؟

**مزایای کلیدی:**

<div dir="ltr">

```
✓ رایگان و باز
✓ مدرن و تمیز (بدون بار گذشته)
✓ مدولار و قابل گسترش
✓ مناسب برای آموزش
✓ پشتیبانی صنعت
✓ محبوبیت در حال رشد
✓ ابزارهای متن‌باز فراوان
```

</div>

**محبوبیت رو به رشد:**

<div dir="ltr">

```
Year    Adoptions
2015    ░
2017    ░░░
2019    ░░░░░░░
2021    ░░░░░░░░░░░░
2023    ░░░░░░░░░░░░░░░░░

روند صعودی قوی!
```

</div>

---

## 💡 نکات کلیدی

### ✅ خلاصه مفاهیم اصلی

**1. انتزاع (Abstraction)**

<div dir="ltr">

```
Application
    ↓
  OS
    ↓
 Compiler
    ↓
  ISA      ◄── لایه انتزاع کلیدی
    ↓
Hardware
```

</div>

**2. جریان کامپایل**

<div dir="ltr">

```
C → Compiler → Assembly → Assembler → 
Object → Linker → Executable → Loader → Execution
```

</div>

**3. چرخه اجرا**

<div dir="ltr">

```
Fetch → Decode → Execute → Write Back
   ↑                            │
   └────────────────────────────┘
```

</div>

**4. ISA = پل**

> ISA رابط بین سخت‌افزار و نرم‌افزار است

**5. RISC-V = آینده**

> معماری باز، مدرن، و در حال رشد

---

## 📚 منابع یادگیری

### 📖 مستندات رسمی

- [RISC-V Specification](https://riscv.org/specifications/)
- [RISC-V Assembly Programmer's Manual](https://github.com/riscv/riscv-asm-manual)

### 🛠️ ابزارها

<div dir="ltr">

| ابزار | کاربرد |
|-------|--------|
| **RARS** | شبیه‌ساز RISC-V |
| **Spike** | شبیه‌ساز رسمی |
| **QEMU** | شبیه‌ساز سیستم کامل |
| **GCC** | کامپایلر |

</div>

### 📚 کتاب‌های پیشنهادی

1. "Computer Organization and Design: RISC-V Edition"
2. "The RISC-V Reader"
3. "Digital Design and Computer Architecture: RISC-V Edition"

---

## ❓ سوالات متداول

### Q1: چرا دستورات RISC-V 32 بیت هستند؟

<div dir="ltr">

**A:** سادگی طراحی:
- Fetch آسان‌تر
- Decode ساده‌تر
- Pipeline یکنواخت‌تر
- Cache کارآمدتر
</div>

### Q2: تفاوت Assembly و Machine Code؟

<div dir="ltr">

**A:**
```
Assembly:  add t0, t1, t2  (قابل خواندن)
Machine:   0x007282B3      (قابل اجرا)
```
</div>

### Q3: چرا RISC-V به‌جای x86؟

**A:**
- رایگان و باز
- ساده‌تر
- مدرن‌تر
- انعطاف‌پذیرتر
- مناسب‌تر برای IoT و Embedded

---

## 🏆 جمع‌بندی

<div dir="ltr">

```
Computer = Hardware + Software
           ↓          ↓
        Processor   Program
           ↓          ↓
      Datapath    Compiler
      Control        ↓
           ↓      Assembly
           ↓          ↓
           ISA ◄──── Assembler
           ↓          ↓
        Execute   Machine Code
```

</div>

### نکات طلایی:

1. **ISA** = قلب معماری کامپیوتر
2. **RISC-V** = معماری آینده
3. **Abstraction** = کلید مدیریت پیچیدگی
4. **Pipeline** = کلید عملکرد
5. **Open Source** = قدرت جامعه

---

<div align="center">



[⬆ بازگشت به بالا](#مبانی-کامپیوتر-و-معماری-isa)

---


📧 سوال دارید؟ بحث کنیم!

</div>

</div>